

##### 执行程序

点击生成，生成解决方案，文档/bin/debug中会有一个exe文件，点击可打开控制台。

程序在运行到最后一行后控制台就会自动关闭。

所以使用Console.WriteLine()作为中止程序的代码行（因为它在等待输入，所以不会执行完毕，按下回车后程序就走到下一行，结束后就关闭了。

程序其实都是运行在内存中的。

##### Console.WriteLine()

在控制台中输出

##### Console.WriteLine()

读取用户在控制台中的输入

按enter键结束

##### 快捷键

注释：ctrl + k + s

对齐：

取消注释：

变量重命名：ctrl + .

快速提取语句作为方法：

快速属性：prop+tab+tab

##### 基础文件解释：

```c#
using System;
// 引入命名空间，下面的Console.ReadLine就是引入的命名空间中的方法，如果不引入需要使用System.Console.ReadLine调用。
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

// 定义命名空间 后续引入这个命名空间就可以使用它里面的类的方法
namespace ConsoleApp1
{
    // 定义类
    internal class Program
    {
        // 定义方法
        static void Main(string[] args)
        {
            // 语句
            Console.WriteLine("请输入用户名");
            string input = Console.ReadLine();
            Console.WriteLine(input);
            Console.ReadLine();
        }
    }
}
```



#### 数据类型

##### 整型

```
1个字节:有符号sbyte(-128~127)，无符号byte(O~255)
2个字节:有符号short(-32768~32767)，与无符号ushort(O~65535)
4字节:有符号int，无符号uint
8字节:有符号long，无符号ulong
```

###### Tips: 其实一般存年龄也用int，不在乎三个字节，且约定俗成。

##### 浮点型

```
4字节:单精度浮点类型float，精度7位。
8字节:双精度浮点类型double，精度15-16位。
16字节:128位数据类型decimal，精度28-29位，适用于财务和货币计算。
注意事项:
	1.非整形变量赋值要加上后缀，如果不加默认为double。2.浮点型运算会出现舍入误差:
	bool number= 1.0f - 0.9f == 0.1f;
	二进制无法精确表示1/10，就像十进制无法精确表示1/3，所以二进制表示十进制会有一些舍入误差，对于精度要求较高的场合会导致代码的缺陷，可以使用decimal代替。
	一般unity存地址，都是用的float。
```

##### 字符类型

```
char字符，2字节，存储单个字符，使用单引号。
string字符串，存储文本，使用双引号。
```

##### bool类型

```
1字节，可以直接赋值true真false假，或者赋表达式做判断。
```

##### 变量声明

```
声明变量：在内存中开辟一块空间，存储变量名与变量值。
赋值：找到变量名所存在的空间，更改该空间的值。
```

#### 基本类型转换

##### 转换语法

```c#
int num = 100;
byte num1 = (byte)num;
在要转换的变量前加(要变成的类型);
```



##### 隐式转换

由小类型到大类型的自动转换。

```
多种类型变量参与的运算，会产生类型提升，结果自动转换为较大字节类型。
byte类型在运算时会自动转化为int类型，因为byte类型运算很容易发生溢出。
但是运算符缩写不会自动转化（+=，-=等等）。
```



##### 显式转换

```c#
手动强制转换。
大类型到小类型的数据可能造成数据丢失，前面的数字字节丢失。
如 
int num = 265;  --------100001001
byte bt = (byte)num;---- 00001001
```



##### ToString转换

```c#
任意类型转换为字符串类型。int num = 100;
string strNumber = num.ToString();
```



##### Parse转换

```c#
字符串类型转换为其他类型string strNumber = "100";
int num = int.Parse(strNumber);
若字符串未被识别为该类型的有效值，则程序抛异常。int number01 = int.Parse("1.0");
float number02= float.Parse("1.Of");
```

##### TryParse

```c#
通过bool表达式配合TryParse使用，防止类型转换失败。语法:
int number;
bool result = int.TryParse( "500”, out number);
```



#### Tips

##### if语句如果只有一行语句，大括号可以省略。

##### int类型相除，如果为非整数的话会向下取整。

##### C#占位符：

```c#
string str = string.Format("第 { 0 } 个点位符", "1" );
```

###### 占位符数据格式化：

```
{0:d2} // 以两位数显示数字（时间格式）
```

##### vs中紫色立方体代表方法，扳手图标代表属性。

##### 代码规范：

```c#
实例成员的初始化放在构造函数中做，而不是在声明成员时做。
例：
private int[] arr = new int[5]; ×
private int[] arr;
public Student()
{
	arr = new int[5]; √
}
```



#### 函数返回值类型

函数返回值必须与定义的返回值类型兼容。

void代表无返回值类型，函数体中可以没有return关键字。

定义函数：

private static 返回值类型 函数名(){

}

#### 方法(函数)

##### 定义：

```c#
[访问修饰符] [可选修饰符] 返回类型 方法名称(参数列表){

	//方法体

	return结果;

}

void代表无返回值类型，方法体中return关键字可有可无。
    
例：
private static void Add(){
    
}

private static int Add(int numberOne,int numberTwo){
    return int a;
}
static int GetWeekByDay(int year,int month,int day){}
调用：
int result = Add(numberOne,numberTwo);
```



##### 方法重载

```
两个方法名称相同，但参数列表不同（如（int hour,int date)与(int hour)。一个为一个参数，一个为两个参数。
用于在不同条件下解决同一类型的问题。
仅仅out与ref的区别不可以构成重载。
官方方法按F12可以查看其重载的方法。按键盘上下键或鼠标左键可以查看下一个。
例：
```

![image-20220517215343284](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220517215343284.png)



#### 参数类型

##### 值参数

```c#
意思是如果是值类型，在方法内部参数值改变不会影响到原变量。
例：
int a = 1;
fun(a);
Console.WriteLine(a); // 1
fun(int num)
{
	num = 2;
}
引用类型因为本身存的就是内存地址，所以修改引用类型的内部数值时会改变原数据。但是如果更改的是被引用的地址就不会影响到原数据。
arr[0] = 1; // 修改引用地址的数据
arr = new Array[]; // 修改被引用地址
默认为值参数。
调用方法时复制实参变量所存储的内容。
作用:传递数据。
语法:
(数据类型参数名[数据类型参数名])
```

##### 引用参数

```c#
即使是传值类型作为参数，也会将值类型的内存地址传进去。修改参数值会影响到方法外部的变量值。
例：
int a = 1;
fun(ref a);
Console.WriteLine(a); // 2
fun(ref int num)
{
	num = 2;
}
使用ref关键字修饰。
调用方法时复制实参变量在栈中的引用。作用:改变数据。
语法∶
...( ref数据类型参数名[,ref数据类型参数名])
```

##### 输出参数

```
当一个方法需要两个或以上返回值时，使用输出参数作为传参参数(至于一个为return,一个为out还是都为out就看个人喜好，都可以)
使用out关键字修饰。
调用方法时复制实参变量在栈中的引用。
作用:返回结果。
语法:
...( out 数据类型参数名[,out 数据类型参数名])
与引用参数区别
ref要求实参必须在传递前进行赋值，
out要求形参离开方法前必须赋值。
```



#### 递归

核心思想：将一个需求层层拆解，限制更小的范围，然后专注解决最后拆解出来的小需求。



#### for循环

i++放在非循环语句中，比如放在if中，可以实现类递归的效果。

```c#
for (int i = 0; i < arr.length;){
    if (arr[i] == 2) {
        .... // 发现为二，不自增，下次进来i还是上一次的i;
    } else {
        i++;
	}
}
```



#### 数组



##### 声明

```c#
数据类型[] 数组名;
初始化的元素类型与声明时的类型必须相同。
例:
int[] array01 = new int[5];
string[] array02 = new string[3];
```



##### 初始化

```
数组初始化后，内存中存储该数据类型的默认值。
-- 整形为О
-- 非整形为0.0
-- char为\0
-- string为 null
-- bool为false
```

##### 初始化＋赋值

```c#
可以在数组初始化的同时对元素进行赋值。语法:
数据类型]数组名=new数据类型{元素1,元素2};
例如∶
int[] array01 = new int[]{ 1,2,3,4,5 };
string[] array02 = new string[]{"a", "b","c"};
初始化时[]内也可以填入数组长度，但必须与所赋值的元素总数一致。
例如∶
double[] array03 = new double[2]{ 1.0,2.0 };
```

##### 声明＋赋值

```c#
可以在数组声明的同时对元素进行赋值。
语法:
数据类型[] 数组名={元素1,元素2};
例如:
int[] array01 = {1,2,3,4,5};
元素个数即为数组长度。
程序员可以省略初始化，但编译器内部仍然会"new数据类型”。
不支持以下写法:
double[] array03;
array03 ={ 1.0,2.0 };
```



##### foreach

```c#
foreach是一种更简单更明了的读取数组元素的语句。
局限性:
    --只能读取全部元素(语句本身)
    --不能修改元素
    --只能遍历实现lenumerable接口的集合对象
语法：
foreach(元素类型 变量名 in 数组名)
{
	变量名表示数组中的每个元素
}
```



##### 数组常用方法

```c#
数组长度:数组名.Length
清除元素值:Array.Clear
复制元素:Array.copy
数组名.CopyTo
克隆:数组名.Clone
查找元素: Array.IndexOf Array.LastIndexOf
排序: Array.Sort
反转:Array.Reverse
若是二维数组，则有
array.GetLength(0);//获取第一维的长度，即行数
array.GetLength(1);//获取第二维的长度，即列数
```

##### 多维数组

```c#
具有两个或多个索引的数组。
语法:
--声明 ＋ 初始化
数据类型[]数组名= new数据类型[行数,列数];
string[,] array01 = new string[3,2];
--初始化 ＋ 赋值
数组名=new数据类型 {元素1,元素2},{元素3,元素4}};
int[,] array02 = new int[,]{{1,2},3,4}};
--读写元素
数组名[行索引,列索引]
```

##### 交错数组

```c#
元素为数组的数组，每个元素都是一个新的一位数组。(可以理解为列长短不一的数组，定义与一般数组不同，赋值与读写都相同。)
语法:
--定义
数据类型[][] 数组名= new 数据类型[元素总数];
string[][] array = new string[3][];
--赋值
数组名[索引= new数据类型[子元素数];
array[0] = new string[2];
--读写元素
数组名[元素索引][子元素索引]
```

##### 参数数组

```c#
方便使用者传参。就是语法糖在形参处默认帮使用者定义了new Array;
在方法形参中通过关键字params定义。
方法调用者可以传递数组，也可以传递一组数据类型相同的变量，甚至可以不传递参数。
注意:
参数数组必须在形参列表中的最后一位。只能在一维数组上使用params关键字。
WriteLine中使用占位符，就是通过参数数组实现的。
例：
private static int Add( params int[] array )
{
    int sum = O;
    foreach (int item in array)
        sum += item;
    return sum;
}

调用:
Add(int[] arr = {1, 2});
Add(1, 2, 3);
Add(); // 结果为0
上述三种调用方式都可。
```



#### 集合类

用类封装的数组，可以理解为js的数组。

#### 数据类型

##### 值类型与引用类型

```
局部变量的值类型:声明在栈中，数据在栈中。
局部变量的引用类型∶声明在栈中，数据在堆中，栈中存储数据的引用。
```

比较引用地址的方法：

```c#
object.ReferenceEquals(s1,s2); // return bool;
```



##### 类型归属

![image-20220619205919779](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20220619205919779.png)

###### 注：C#中string类型是引用类型(因为不知道字符串长度);



##### 内存分配

```
程序运行时，CLR将申请的内存空间从逻辑上进行划分。
栈区:
--空间小(1MB)，读取速度快。
--用于存储正在执行的方法，分配的空间叫做栈帧。栈帧中存储方法的参数以及变量等数据。方法执行完毕后，对应的栈帧将被清除。
堆区:
--空间大，读取速度慢。
--用于存储引用类型的数据。
```

##### 局部变量(与js不同)

```
定义在方法内部的变量。
特点:
--没有默认值，必须自行设定初始值，否则不能使用。--方法被调用时，存在栈中，方法调用结束时从栈中清除。
```

##### 成员变量

```
定义在类中方法外的变量
特点:
--具有默认值。
--所在类被实例化后，存在堆中，对象被回收时，成员变量从堆中清除。
--可以与局部变量重名。
```



#### 拆装箱

##### 装箱(box)

```
值类型隐式转换为object类型或由此值类型实现的任何接口类型的过程。
例：形参object类型，实参传递值类型，则装箱。
可以通过重载、泛型避免。
内部机制:
1.在堆中开辟内存空间(需要一块数据空间，一块同步块索引空间，一块类型对象指针空间。
所以相对比较消耗性能，但是相对其他优化可以忽略不计。)
⒉将值类型的数据复制到堆中
3.返回堆中新分配对象的地址
```

##### 拆箱(unbox)

```
从object类型到值类型或从接口类型到实现该接口的值类型的显式转换。
内部机制:
1.判断给定类型是否是装箱时的类型
2.返回已装箱实例中属于原值类型字段的地址
```

##### 注意

```
拆箱后的类型必须与装箱时的类型相同。
伴随拆箱的字段复制步骤不属于拆箱过程。
装箱和拆箱不是互逆的过程，装箱的性能开销远大于拆箱。
```



#### string

##### 特性

```
字符串常量具备字符串池特性
	字符串常量在创建前，首先在字符串池中查找是否存在相同文本。如果存在，则直接返回该对象引用;如果不存在，则开辟空间存储。
	目的:提高内存利用率。

字符串具有不可变性
	字符串常量一旦进入内存，就不得再次改变。因为如果在原位置改变会使其他对象内存被破坏，导致内存泄漏。当遇到字符串变量引用新值时，会在内存中新建一个字符串，将该字符串地址交由该变量引用。
```



#### 枚举

##### 简单枚举

```
列举某种数据的所有取值。(单选框)
作用:增强代码的可读性，限定取值。
语法: enum 名字{值1，值2，值3，值4}。
枚举元素默认为int，准许使用的枚举类型有byte、sbyte、short、ushort、int、uint、long或ulong。
每个枚举元素都是有枚举值。默认情况下，第一个枚举的值为0，后面每个枚举的值一次递增1，可以修改值，后面枚举数的值依次递增。
```

##### 标志枚举

```c#
可以同时赋多个枚举值。(可复选)
条件:
--任意两个枚举值做按位或运算的结果不能与其他枚举值相同。
--使用[Flags]特性标记枚举类型。
语法:
[Flags]
enum枚举类型名称{
	枚举值1= 1,
	枚举值2= 2,
	枚举值3= 4,
	枚举值4= 8,
	枚举值4= 16,
}
```



#### 类与对象

##### 语法：

```c#
访问级别 class 类名 {
    字段
    属性
    构造函数
    方法
}
例：
class User
{
    // 字段 存储数据的变量
    private string name;
    private string loginld;
    private string Password;
    
    // 属性 get set属性的方法，与字段同名并大写。
    public string Name
    {
        get
        {...}
        set
        {...}
    }
    // 自动属性
    // public string Name {get;set;}
    
    // 构造函数 若不手动添加，编译器会自动加一个构造函数，若手动添加则没有
    public User(){
    }
    
    // 构造函数的重载
    public User(string loginld, string pwd){
        this.loginld = loginld;
        this.Password = pwd;
    }
    
    // 方法
    public void PrintUser(){
        Console.WriteLine("账号:{0}，密码:{1}",Loginid, Password);
    }
}
通常每个类都在一个独立的c#源文件中。
创建新的类意味着在当前项目中产生了一种新的数据类型。
```

###### 访问修饰符

```
用于修饰类及类成员的访问可见范围。
public:所属类的成员以及非所属类的成员都可以访问。
private:只有所属类的成员才能访问。[类成员的默认级别]。
```

###### 属性

```
对字段起保护作用，可实现只读、只写功能。
本质就是对字段的读取与写入方法。
语法∶
[访问修饰符]数据类型属性名
{
	get { return 字段; }
	set { 字段 = value; }
}
通常一个公有属性和一个私有字段对应。
属性只是外壳，实际上操作的私有字段。
当属性访问器中不需要任何其他逻辑时，使用自动属性可以更加简洁。例：见上文。
```

###### 构造函数

通过:this调用构造函数重载。

```
提供了创建对象的方式，初始化类数据成员的特殊方法。
与类同名。
没有返回值，也不能写void。
不能被直接调用，必须通过new运算符在创建对象时才会自动调用。
每个类都必须至少有一个构造函数，若不提供，编译器自动生成一个无参构造函数。
如果程序员定义了构造函数，则编译器不会再提供。
```

##### this关键字

```
表示当前对象的引用。
访问当前类成员时，使用this关键字，可以提高代码的可读性;在没有歧义的情况下，也可以省略。
```



#### 字典集合



#### 继承

```c#
父类型的引用指向子类的对象
只能使用父类成员
Person person02 = new Student();
如果需要访问该子类成员，需要强制类型转换
Student stuo2 = (Student)person02;
```



#### Static

##### 静态成员变量

```
使用static关键字修饰的成员变量。
静态成员变量属于类，类被加载时初始化，且只有一份。
实例成员变量属于对象，在每个对象被创建时初始化，每个对象一份。
特点:存在优先于对象，被所有对象所共享，常驻内存。
```

##### 静态构造函数

```
初始化类的静态数据成员。
仅在类被加载时执行一次。
不允许使用访问修饰符。
```

##### 静态方法

```
通过引用调用实例方法时，会隐式的传递对象引用，以便在方法内部可以正确访问该对象成员变量。
通过类名调用静态方法时，因为没有具体对象，所以在static方法中不能访问实例成员。
```

##### 静态类

```
使用static关键字修饰的类。
不能实例化，只能包含静态成员。
静态类不能被继承，但是静态方法、属性都可以被继承。
```

##### 适用性

```
利:单独空间存储，所有对象共享，可直接被类名调用。
弊:静态方法中只能访问静态成员，共享数据被多个对象访问会出现并发。
适用场合:
1.所有对象需要共享的数据。
2.在没有对象前就要访问成员。
3.工具类适合做静态类(常用，不需要过多数据)。
```



#### 结构 struct

##### 结构属于值类型，类属于引用类型。

```
定义:用于封装小型相关变量的值类型。
与类语法相似，都可以包含数据成员和方法成员。
但结构属于值类型，类属于引用类型。
适用性:
表示点、颜色等轻量级对象。
如创建存储1000个点的数组，如果使用类，将为每个对象分配更多内存，使用结构可以节约资源。
```

##### 语法

```
使用struct关键字定义。
除非字段被声明为const或 static，否则无法初始化。
结构不能继承，但可以实现接口。
结构总会包含无参数构造函数。
构造函数中必须初始化所有字段。
```

