

# 一、JS的组成



## 1.1 组成

BOM(浏览器对象模型)、DOM(文档对象模型)、ECMAScript(核心语法)

# 二、ECMAScript



## 2.1 简介

​	JavaScript是一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML(标准通用标记语言下的一个应用)网页上使用，用来给HTML网页增加动态功能。

## 2.2 ECMAScript

JS是JavaScript的简称，ECMAScript是JS的核心语法，简称ES。ES又分成不同的版本。我们现在将要学习的是ES3.1。

现在的版本：

​	2009年出现了ES5

​	2015年出现了ES6

​	之后每一年出一个新版本

## 2.3 计算机的作用

计算机的作用就是处理数据。

所以，一门计算机语言，它一定要对数据进行规定。

所以，ES对数据进行了分类。

## 2.4 数据类型介绍

 1. 值类型(又可以叫做基本数据类型)

     1. 数字
     2. 字符
     3. 布尔值(true、 false)
     4. undefined
     5. null
     6. symbol(ES6中新增)

 2. 引用类型(又叫做对象类型)

      ​	总的来说，只要不是上面的五种，就属于引用类型

      	1. Array    
      	2. Object
      	3. Function
      	4. RegExp
      	5. ......

## 2.5 JS的书写位置

### 2.5.1 HTML的script标签

```HTML
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    // JS代码书写在这里
  </script>
</body>
</html>
```

### 2.5.2 JS文件中

![1608514927042](images/1608514927042.png)

一个是JS文件中，一个是HTML文件中的script标签里。

如果是JS文件的话，那么我们需要通过script标签的src属性，把它引入。

```HTML
<script src="01.js"></script>
```

区别就在于：最终HTML文件的体积。体积影响了传输速度。所以，记住，以后我们写代码都往JS文件中写。

## 2.6 script标签的书写位置

### 2.6.1 body标签的末尾

```
<body>
  ...
  ...
  ...
  <h1>今天是js的第一天</h1>
  <!-- 上面是HTML  下面是JS -->
  <script>
    // JS代码书写在这里
    // document.write('<h1>今天是JS的第一天</h1>')
  </script>
  <script src="01.js"></script>
</body>
```

为什么要放在这里?

因为浏览器在执行代码的时候是从上往下执行，而JS又是可以操作元素的。必然要先有元素再执行JS才是合理的。

### 2.6.2 head标签的末尾

有时我们会见到放在head标签末尾的JS，这是因为它里面的代码被推迟了执行时间。

  <script>
    window.onload = function() {
      alert("所有资源加载完毕了")
    }
  </script>

> window.onload 这是一个后面要讲的"事件" 它会在当前页面所需的所有资源加载完毕之后执行。

补充： 一个script标签 如果设置了src 就不要再在里面写代码了

## 2.7 变量

每一门真正的语言，都会提供"变量"。

![1608516461232](images/1608516461232.png)

所谓的变量，就是定义一个容器， 保存一个数据。

之后每一次使用变量都是在使用这个数据。

为什么叫变量，当然是因为它的内容可变。

### 2.7.1 定义变量

​	语法1：  **var  变量 **

​	语法2： **var 变量 = 初始值**

```
var num1;
var num = 3;
```

​	如果一个变量只是定义(定义也叫声明)了，没有给初始值，此时它的值是undefined。

### 2.7.2 变量的命名规范

1. 整体由数字、字母、下划线、美元符号组成
2. 不可以由数字开头
3. 不能使用关键字、保留字当做变量名称
4. 严格区分大小写
5. 推荐使用驼峰命名法

关键字、保留字见下图

![1608517692324](images/1608517692324.png)

## 2.8 数据类型详解

### 2.8.1 字符串

定义：单引号 ' 或者 双引号 "   推荐使用 单引号

```
var str = "这就是一段字符串";
var str1 = '我是一个新字符串';
```

注意： 单引号开头，就必须单引号结尾。双引号开头就必须双引号结尾。

![1608532467466](images/1608532467466.png)

**转义字符**

JS的字符串中，有转义字符这么一个概念。为了解决部分符号具备双重含义的特点。

```
var str ="'你好啊!'. Tom说：\"今天天气不错啊\""
```

\就是用于转义的符号 

转义字符有： \b  \n \t  等 

### 2.8.2 数字

定义数字就是直接用键盘敲，默认是十进制。

![1608533335596](images/1608533335596.png)

拓展： 定义其它进制的数字

定义二进制： 0b101

定义八进制：055    0o55

定义十六进制： 0xfff

特殊数字：

​	NaN 表示 "不是一个数"

​	Infinity 表示 "无穷大"

​	-Infinity 表示 "无穷小"

### 2.8.3 布尔值、undefined、null

布尔值： true、 false

undefined： undefined

null：null



![1608534903275](images/1608534903275.png)

## 2.9 数据类型判定

typeof 关键字 这个关键字的作用：判定数据类型

判定字符串   

```
var str = '明月松间照';
console.log(typeof str)
```

结果

![1608535165847](images/1608535165847.png)

判定数字

```
 var num = 123
 console.log(typeof num)
```

结果

![1608535259928](images/1608535259928.png)

判定布尔值

```
var bool = true
console.log(typeof bool)
```

结果

![1608535326915](images/1608535326915.png)

判定undefined

```
var und = undefined
console.log(typeof und)
```

结果

![1608535372457](images/1608535372457.png)

判定null(这是一个bug，记住这一点，ES是不会修复它的)

```
var nulls = null
console.log(typeof nulls)
```

结果

![1608535432657](images/1608535432657.png)

## 2.10 数据类型转换

### 2.10.1 数字转字符串

1. String()
2. toString()
3. 拼接空字符串
4. toFixed()

```
var num = 1.234;


// String() 是字符串的一个函数 它可以将非字符串转为字符串
var str = String(num)
console.log(str)

// toString()
var str1 = num.toString()
console.log(str1)

// 拼接空字符串
var str2 = num + ''
console.log(str2)

// toFixed()
var str3 = num.toFixed(2)
console.log(str3)
```

结果：

![1608536692870](images/1608536692870.png)

### 2.10.2 字符串转数字

1. parseInt
2. parseFloat
3. Number()
4. +

```
// parseInt() 将字符串尽可能的转为数字整数
var num = parseInt(str)
console.log(num)
// parseFloat() 将字符串尽可能的转为数字小数
var num1 = parseFloat(str)
console.log(num1)
// parseInt和parseFloat都是能转几个就转几个 实在一个都没有返回NaN

// Number()
var num2 = Number(str)
console.log(num2)
// +
var num3 = +str
console.log(num3)
// Number() 只要不能完全转为数字 就是NaN
// + 我们可认为是Number的简写
```

结果

![1608537242116](images/1608537242116.png)

## 2.11 运算符

JS中的运算符分为很多种包含： 算术运算符、比较运算符(关系运算符)、逻辑运算符、三元运算等

### 2.11.1 算术运算符

算术运算符包含  

```
 +  -  *  /  %  
```

加号(+) 在我们JS中有两个含义： 连字符、加法运算

规则：只要两边有任何一边是字符串，就会被当做连字符

code:

```
console.log(1 + 2);
console.log(1 - 2);
console.log(1 * 2);
console.log(1 / 2);
console.log(1 % 2);
```

结果：

![1608601422219](images/1608601422219.png)

**自增自减运算符**

```
 ++ 与 -- 都表示自运算符号 
var d = 44;
console.log(++d)    
console.log(--d) 
```

 如果放在变量前面(左边) 那么会先+1或者-1再参与运算 如果放在变量后面(右边) 会先运算再+1或者-1

### 2.11.2 比较运算符

如下：

```
>    大于
>=   大于等于
<    小于
<=   小于等于
==   相等
!=   不相等
===  全等
!==  不全等
```

重点在于 == 和===的区别

​	== 叫做相等 

​		它会把两边的值向同一类型转化 转换完毕之后再比较 

​	=== 叫做全等 

​		它不会转换类型 比较的时候先比较类型是否一致 

​		如果一致 再比较值是否一致 如果类型已经不一致 不再比较值 

### 2.11.3 逻辑运算符

**逻辑与 &&**  

**逻辑或 ||** 

**逻辑非 !**

```
// 逻辑与 &&   逻辑 ||    逻辑非 !
console.log(true && true)   // true
console.log(false && true)  // false
console.log(true && false)  //false

console.log(true || false)  // true
console.log(false || true)  // true
console.log(false || false) // false
 
console.log(!0)    // true
console.log(!'')   // true
console.log(!undefined) // true
console.log(!null) // true 
console.log(!NaN)  // true
```

> 在整个JS，所有的数据中，只有: 0 "" undefined null NaN 是false的性质



### 2.11.4  三元运算符

三元运算符也叫作三目运算符

指的是整个运算表达式由3个部分组成

a ? b : c

```
var result = 1 < 2 ? "hehe" : "哈哈";
// result => 'hehe'
```

执行机理：

​	通过 ? 和 : 把整个表达式分成了3段 

​	对第一段做判定 如果为真 使用第二段 如果为假 使用第三段

## 2.12 分支判断语句

JS中，可以根据不同的条件执行不同的代码。此时，就需要分支判断语句。

JS中，分支判断语句有两种： if 语句、   switch 语句

### 2.12.1 if语句

语法：

```
第一种： 单if判断
if () {}  

第二种： 多分支条件
if () {} 
else if () {}
....
else if () {}

第三种： if else判断
if () {} else {}

第四种：
if () {} else if () {} else {}
```

### 2.12.2 switch语句

语法：

```
switch (变量) {
	case 值:
	break;
	case 值1:
	break;
	...
	default: 
	break;
}
```

执行机制：

对switch()中的变量做判定，与每一个case 进行比对 如果匹配成功，则执行对应的代码，执行完之后如果遇见了break就跳出switch语句。如果没有遇见break会"掉"到下一个case中，不论case条件是否匹配
如果没有任何一个case匹配上 会执行default 中的代码 default可以省略

## 2.13 循环语句(重难点)

循环：指的是一遍又一遍的做事情。

在JS中，我们目前要学习的循环有3个。 

1. while
2. do while
3. for

注：写循环代码的时候，要格外注意死循环的情况。

### 2.13.1 do while循环

语法：

```
do {
	代码...
} while(条件)
```

执行顺序：先执行一次代码块中的代码 然后判断条件，如果条件为真 继续执行代码块中的代码 如果条件为假 终止循环

> do while的特点：先执行一次循环体的代码 再进行判定 

### 2.13.2 while循环

语法：

```
while (条件) {
    代码...
}
```

执行顺序：先判定 如果条件符合，开始循环。如果条件不符合，循环就不开始直接跳过。

### 2.13.3 for循环

语法：

```
for (1定义循环变量; 2结束条件; 4改变循环变量) {
	3执行代码
}

第一次执行： 1 2 3 4 
之后的每一次执行： 2 3 4 2 3 4 2 3 4...
直到某一次2的时候不再符合条件此时结束循环
```



### 2.13.4 break和continue

break：结束循环

continue: 跳过本次循环

注：它们可以用在任何循环语句中

# 三、函数

声明：函数属于ECMAScript语法中的一项。但是因为它实在是太过于重要，所以单独讲。

## 3.1 什么叫函数

我们现在刚刚接触函数，暂且把函数理解为一个代码容器。用于装代码的。

## 3.2 函数的定义

> 注：定义了一个函数，该函数不会执行 需要调用才会执行

1. 函数声明 
   1. 可以在任何地方调用这个函数 既可以在声明代码之前 又可以在声明代码之后
2. 函数表达式
   1. 只能在定义函数完毕之后再调用这个函数
3. 构造函数式

### 3.2.1 函数声明

```
语法： function 函数名 () {}


// 定义函数
function fun() {
  alert(10)
}
```

### 3.2.2 函数表达式

```
语法： var 变量名 = function() {}

// 定义函数
var fun1 = function() {
	alert(10)
}
```

### 3.2.3 构造函数式(了解)

```
语法： var 变量名 = new Function(参数1，参数2，参数3，...函数体)


// 定义函数
var fun2 = new Function('console.log(10)')

```

## 3.3 函数的调用

常规调用：

调用非常简单，通过  **函数名()**  的方式进行调用即可

```
function fun() {
	console.log(111)
}
fun();
```

IIFE调用： 立即执行函数

```
(function () {
  console.log(111)
})();
```



## 3.4 函数的作用

1. 复用代码
2. 封装代码

## 3.5 函数的参数

函数是一段代码的封装。

当函数执行的时候，函数体内的代码会执行。

我们可以传递一些数据参与运算。这个就是函数的参数。

函数的参数分为实参和形参。

​	实参：函数调用的时候真实传递进去的数据，叫做实际参数，简称实参。

​	形参：函数定义的时候写在形参列表中的变量，叫做形式参数，简称形参。

形参与实参的对应关系： 按照顺序，一一对应。

![1608709009379](images/1608709009379.png)

## 3.6 函数的返回值

函数体内有一个专属的关键字 return

作用 

1. 是向函数的调用处返回一个值

 	2. 终止函数的执行

```
function qiuhe(a, b) {
  var result = a + b; 
  return result; 
}

var he = qiuhe(10, 20);
// he => 30
```

![1608710011360](images/1608710011360.png)

## 3.7 arguments

​	arguments是函数中的一个内置对象 

​	只能在函数里面使用 

​	一个函数对应一个arguments

​	它里面装的是所有传递进来的实参

​	它长得非常像数组 但是因为它没有数组的方法 所以我们只能说它是类数组\伪数组

```JS
function sum() {
  var sum = 0;
  //  arguments.push(1) // 报错：arguments.push is not a function
  for (var i = 0; i < arguments.length; i++) {
    sum += arguments[i]
  }
  return sum;
}
```

## 3.8 递归(重要、了解)

递归指的是函数的一种 **自己调用自己**的调用方式

简单来说，递归就是函数自己调用自己
它主要用在使用循环不好做的情况下

![](images/digui-1609136656982.gif)

求斐波那契数列

```
function fibonacci(num) {
  if (num === 1 || num === 2) {
    return 1;
  }
  return fibonacci(num - 1) + fibonacci(num - 2)
}
```

阶乘

```
function jc(num) { 
  if (num === 1) {
    return 1;
  }
  return num * jc(num - 1);
}
```

## 3.9 this

this是函数内的一个对象，它表示'上下文'

定义一个函数

```JS
function demo() {
  console.log(this);
}
```

this只能在函数调用的时候确定

1. 在事件函数中，this指向绑定事件的元素

   ```JS
   document.onclick = demo; // 当点击时 this指向document
   ```

2. 当函数自己调用的时候，this指向window(非严格模式下)

   ```JS
   demo(); // window
   ```

3. 当函数作为对象的方法调用的时候，指向调用的对象

   ```JS
   var obj = {
     name: "小明"
   }
   obj.fun = demo;
   obj.fun(); // {name: "小明", ...}
   ```

4. setInterval中

   ```JS
   setInterval(demo, 1000); // window	
   ```

> 总结：函数中的this遵循两条规则 
>
> 1 谁调用指向谁 
>
> 2 调用者不明确 指向window

# 四、作用域

作用域：是JS中的一个规则。规定了变量和函数起作用的区域。

![1608791509934](images/1608791509934.png)

## 4.1 作用域划分

作用域分为全局作用域和函数作用域

![1608791825551](images/1608791825551.png)

## 4.2 作用域的规则

### 4.2.1 访问规则

作用域是控制变量的使用范围，对变量的操作有两种： 使用变量和给变量赋值。使用变量就是访问变量。

```JS
var a = 133;
function demo() {
	console.log(a);
}
```

作用域内的变量不可以被作用域外访问。但是作用域内可以使用作用域外的变量。

>  先查看当前作用域中有没有声明过这个变量 
>
> ​	如果有就直接用 如果没有 会向上层作用域去找 
>
> ​	有就用，没有就继续向上
>
> ​	重复这个过程
>
> ​	直到找到变量或者到了全局发现全局依然没有这个变量 此时会报错

### 4.2.2 赋值规则

给变量赋值

```
function demo() {
  a = 2333;
}
console.log(a) // 2333
```

给变量赋值的时候，会遵守以下规则:

> 先查看当前作用域中有没有声明过这个变量 
>
> ​	如果有就直接赋值 如果没有 会向上层作用域查找
>
> ​	如果有就修改这个作用域中的变量 如果没有继续向上 
>
> ​	重复这个过程 
>
> ​	直到找到变量 或者到了全局依然没有 
>
> ​	此时不会报错，**而是会悄悄地把它注册为全局变量**

## 4.3 声明提升

声明提升：在预解析的过程中，把变量、函数声明提升到作用域的最开头。

思考如下代码：

```
var a = 2;
```

你可以理解为： 声明一个变量为其分配内存，命名为a，并将2保存进这个变量中。

事实上：

```JS
遇到 var a; 编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域中声明一个新的变量，并命名为 a。
接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量.
```

如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则就会注册为全局变量！

声明提升不仅会发生在全局作用域，而且也会发生在函数作用域中(在函数执行的时候)

# 五、数组

数组是JS中的一个数据容器。它是引用类型之一。

它的作用非常简单，就是用来装多个数据。

## 5.1 定义数组

1. 字面量
2. 构造函数

字面量语法：

```
var arr = [成员1, 成员2, 成员3, ...];
```

构造函数语法：

```
var arr = new Array(成员1, 成员2, 成员3, ...)
```

> 小bug:当参数只有一个且参数的类型是数字时 会被当做数组的长度

![1608860940675](images/1608860940675.png)

## 5.2 数组的使用

数组是由 **成员+下标** 组成的

![1608861255608](images/1608861255608.png)

假设已有数组: ['张三', '李四', '王五', '赵六']

获取成员'张三'

```JS
var arr = ['张三', '李四', '王五', '赵六']
console.log(arr[0])
```

添加成员/修改成员

```JS
// 构造函数定义一个数组
var arr = new Array('张三', '李四', '王五', '赵六')

// 添加成员
arr[4] = '龚七'
console.log(arr)
// 修改成员
arr[2] = '王老五'
console.log(arr)
```

## 5.3 数组的属性length

数组有一个属性 length 表示数组有多少个成员

这个属性可读可写

```JS
var arr = [];
console.log(arr.length) // 读取length属性 

arr.length = 10; // 设置length属性
console.log(arr.length)
```

> PS: length属性虽然可读可写但是我们一般只读

## 5.4 数组的方法

### 5.4.1 unshift

作用：头部增加

返回值：数组的新长度

```
var arr = ['张三', '李四', '王五', '赵六'];
arr.unshift('王二')
console.log(arr); 
// ["王二", "张三", "李四", "王五", "赵六"]
```

### 5.4.2 shift

作用：删除数组的头部第一项

返回值：被删除的那一项

```JS
var arr = ['张三', '李四', '王五', '赵六'];
var result = arr.shift()
console.log(result); // 张三
console.log(arr) //  ['李四', '王五', '赵六'];
```

### 5.4.3 push

作用：尾部增加

返回值：数组的新长度

```JS
var arr = ['张三', '李四', '王五', '赵六'];
var result = arr.push('王二')
console.log(result); // 5
console.log(arr); // ["张三", "李四", "王五", "赵六", "王二"]
```



### 5.4.4 pop

作用：尾部删除

返回值：被删除的那一项

```
var arr = ['张三', '李四', '王五', '赵六'];
var result = arr.pop();
console.log(result); // 赵六
console.log(arr) //["张三", "李四", "王五"]
```

### 5.4.5 concat

作用：合并

参数：任意个、任意类型

返回值：一个新的合并后的数组

特点：没有改变原来的数组

```
var arr = ['张三', '李四', '王五', '赵六'];
var arr1 = arr.concat(1, '你好', true, undefined, null, ["a", "b", "c"])
console.log(arr)
console.log(arr1)
```

### 5.4.6 slice

作用：截取

参数：

1. 没有参数  截取全部

 	2. 一个参数  从指定位置截取到最后
 	3. 两个参数 从指定开始位置截取到指定的结束位置
      	1. 这两个参数都是下标
      	2. 开始位置(包含)
      	3. 结束位置(不包含)

特点：不改变原数组

```JS
没有参数
var arr = ['张三', '李四', '王五', '赵六'];
var arr1 = arr.slice();
console.log(arr1)  //  ["张三", "李四", "王五", "赵六"]

一个参数
var arr = ['张三', '李四', '王五', '赵六'];
var arr2 = arr.slice(1);
console.log(arr2) // ["李四", "王五", "赵六"]

两个参数
var arr = ['张三', '李四', '王五', '赵六'];
var arr3 = arr.slice(1, 3);
console.log(arr3) // ["李四", "王五"]
```

> PS: 如果参数是负数  那么表示从后往前数 最后一个值是-1

### 5.4.7 splice

作用：用于操作数组成员

参数：

1. 操作位置

 	2.  删除个数
 	3.  从第三个参数开始是添加的成员

返回值：被删除的那些成员组成的数组

特点：会改变原数组

```
var arr = ['张三', '李四', '王五', '赵六'];
// 删除
var result = arr.splice(1, 2)
console.log(result); // ["李四", "王五"]
console.log(arr); // ["张三", "赵六"]   


// 插入
var arr = ['张三', '李四', '王五', '赵六'];
var  result = arr.splice(2, 0, '小绵羊');
console.log(result); // []
console.log(arr) // ["张三", "李四", "小绵羊", "王五", "赵六"]

// 替换
var arr =['张三', '李四', '王五', '赵六'];
var result = arr.splice(2, 2, '小绵羊', '大绵羊');
console.log(result); // ["王五", "赵六"]
console.log(arr) // ["张三", "李四", "小绵羊", "大绵羊"]
```



### 5.4.8 indexOf

作用： 查找

返回值：下标 

参数：

	1. 被查找的成员
 	2. 查找的开始位置(可选)

```JS
var arr =['张三', '李四', '王五', '赵六'];
var result = arr.indexOf('李四'， 2);
console.log(result); // -1
console.log(arr); // ['张三', '李四', '王五', '赵六']
```



### 5.4.9 join

作用：转字符串

返回值：字符串

参数： 拼接符号(可选)

```
var arr =['张三', '李四', '王五', '赵六'];
var str = arr.join();
console.log(str); // 张三,李四,王五,赵六
var str1 = arr.join('+');
console.log(str1); // 张三+李四+王五+赵六 
var str2 = arr.join('❤');
console.log(str2); // 张三❤李四❤王五❤赵六
```

### 5.4.10 reverse

作用：将数组的成员倒序

返回值：原数组

参数：无

特点：会改变原数组

```JS
var arr =['张三', '李四', '王五', '赵六'];
var arr1 = arr.reverse();
console.log(arr) // ["赵六", "王五", "李四", "张三"]
console.log(arr1) // ["赵六", "王五", "李四", "张三"]
console.log(arr === arr1) // true
```

### 5.4.11 sort

作用：将数组成员按照指定规则排序

返回值：原数组

参数：规则函数

特点：会改变原数组

```JS
var arr = [1, 44, 6, -7, 99, 145, 5555, 0]
var arr1 = arr.sort(function (a, b) {
  return a - b
})
console.log(arr) // [-7, 0, 1, 6, 44, 99, 145, 5555]
console.log(arr1) // [-7, 0, 1, 6, 44, 99, 145, 5555]

```



## 5.5 交换两个变量的值

```
var a = 4;
var b = 5;

// 交换两个变量的值要借助第三个变量
var c = b;
b = a;
a = c;

console.log(a); // 5
console.log(b); // 4
```



## 5.6 数组排序

 ![img](images/849589-20171015223238449-2146169197.gif) 

```
for (var j = 0; j < arr.length - 1; j++) {
  for (var i = 0; i < arr.length - 1 - j; i++) {
    if (arr[i] > arr[i + 1]) {
      var temp = arr[i];
      arr[i] = arr[i + 1];
      arr[i + 1] = temp;
    }
  }
}
```

## 5.7 二维数组

一句话：一个数组的每一个成员也是数组，这就叫做二维数组。

一维数组： [1, 2, 3, 4, 5, 6]

二维数组：

[

​	 [1, 2, 3, 4, 5, 6],

​	 [1, 2, 3, 4, 5, 6],

​	 [1, 2, 3, 4, 5, 6]

​	...

]

# 六、对象

## 6.1 对象的定义

JS中的对象就是一个数据容器，也叫作数据结构。

它的作用与数组一致，都是用来装载数据。 

​	数组的结构： 下标 => 成员

​	对象的结构： 名(键) => 值

​	名：就是字符串 

​	值：任意数据类型

一组键:值，就是一条属性。属性之间没有顺序要求。

> 总结：对象是属性的无序集合，
>
> 顺便一提：当属性的值是函数时，我们管它叫做对象的方法。

### 6.1.1 字面量

```JS
var obj = {
	key： value,
	key1: value1,
	...
};
```

![1608948368980](images/1608948368980-1608948399318.png)

### 6.1.2 构造函数

```JS
var obj = new Object();
```

## 6.2 对象属性操作

### 6.2.1 添加属性

点语法添加属性： 点语法：点什么就是什么

```JS
 var zhangsan = {}
 zhangsan.height = '180cm'
 console.log(zhangsan); // {height: "180cm"}
```

方括号语法添加属性： 最终方括号中要求有一个值 该值必须是字符串 如果不是会转为字符串

```JS
var zhangsan = {}
zhangsan['weight'] = '60kg';
var i = 'age'
zhangsan[i + 1] = 19;
console.log(zhangsan); // {weight: '60kg', age1: 19}
```



### 6.2.2 删除属性

**delete** 这是一个关键字 用于删除对象的属性

``` delete
delete obj.name; 
```



### 6.2.3 读取属性

 1.  方括号语法 最终方括号内必须是字符串

     ```
     // 定义一个对象
     var obj = {
       "name": "张三",
       "girl-----------------Friend": {
         "name": "小红"
       }
     }
     
     console.log(obj['name'])// 张三
     console.log(obj['girl-----------------Friend']) // {name: '小红'}
     ```

     > 方括号语法内要的是一个字符串

 2.  点语法 点什么就是什么

     ```
     // 定义一个对象
     var obj = {
       "name": "张三",
       "girl-----------------Friend": {
         "name": "小红"
       }
     }
     console.log(obj.name) // 张三
     // 点语法无法读取不遵守变量命名规范的属性名
     ```

     

## 6.3 for...in

```
for (var i in zhangsan) {
	// i 是循环变量
}
```

> 这个是一个新语法 这个循环专门用于循环对象
>
> 循环次数：根据对象的属性条数决定
>
> i 表示循环变量 它在每一次循环中表示的是对应的属性名
>
> 想要访问属性值 必须使用方括号语法

### 6.3.1 循环对象

```
// 定义一个对象
var zhangsan = {
  name: "张三",
  age: 20,
  sex: "男",
  height: 180,
  weight: 140,
  girlFriend: null
}
for (var i in zhangsan) { 
  console.log(i, zhangsan[i]) 
}
```

![1608964479491](images/1608964479491.png)

### 6.3.2 循环数组

```
var arr = [1, 2, 3, 4, 5];
for (var i = 0; i < arr.length; i++) {
  console.log(i, arr[i])
}
```

![1608964538658](images/1608964538658.png)



## 6.4 深浅复制(深浅拷贝)

### 6.4.1 浅复制

假设有对象如下,现有需求，复制一份数据。

```
var obj = {
	name: "小李",
	age: 22,
	sex:"女",
	boyFriend: {
		name: "老李",
		age: 33,
		sex: "男"
	}
}
```

于是我们写代码如下：

```
var obj1 = {}
for (var i in obj) {
	obj1[i] = obj[i]
}
```

结果如图：

![1610007664301](images/1610007664301.png)

这就是浅复制，仅仅只是复制了值类型属性，引用类型属性没有真的复制。

如果此时修改obj.name  不会影响到obj1.name

```
obj.name = "小王";
console.log(obj1.name)
```

![1610007800684](images/1610007800684.png)

但是如果修改obj.boyFriend.name 将会影响到obj1.boyFriend

```
obj.boyFriend.name = '老王';
console.log(obj1.boyFriend.name)
```

![1610007904056](images/1610007904056.png)

### 6.4.2 深复制

示意图

![1610008040631](images/1610008040631.png)



```JavaScript
function deepCopy(target) {
  var obj1 = {}
  for (var i in target) {
    // 判定这条属性是值类型的值还是引用类型的值
    if (typeof target[i] === 'object' && target[i] != null) {
      obj1[i] = deepCopy(target[i]);
    } else {
      // 值类型
      obj1[i] = target[i];
    } 
  }
  return obj1;
}
```

过程图

![1610008710616](images/1610008710616.png)

# 七、引用类型与值类型

内存中比较值类型

![1608965000911](images/1608965000911.png)

内存中比较引用类型时

![1608965456110](images/1608965456110.png)

----

如下代码，当一个变量保存另一个变量的值时

如果是值类型，与内存中比较值类型一致

如果是引用类型

```
var a = {};
```

![1608966262699](images/1608966262699.png)

```
var a = {};
var b = a;
```

![1608966348244](images/1608966348244.png)

>  总结：值类型与引用类型 
>
>   1 存储位置不同 值类型在栈内存中 引用类型在堆内存中
>
>   2 用变量去接收另一个变量保存的内容时 如果是值类型 复制一个值 如果是引用类型 复制地址

# 八、字符串方法

字符串本身确确实实没有方法 是它们的包装类型有方法

包装类型：为了方便操作字符串、操作数字、操作布尔值，JS内置了一些对应的引用类型。

当我们写代码的时候

```
var str = 'abcdefg';
str.方法() 
```

但是JS引擎会悄悄地调用对应的引用类型中的方法

```
var str = 'abcdefg';
var strObj = new String(str);
strObj.方法();
strObj = null;
```

**字符串的所有方法都不会改变原字符串**

## 8.1 concat()

作用：拼接字符串

参数：被拼接的字符串

返回值：拼接之后的字符串

```
var str = 'a';
var result = str.concat('b')
console.log(result) // ab
```

## 8.2 slice()

作用：截取字符串

参数：同数组

返回值：截取到的字符串

```
var str = 'abcdefg';
var str1 = str.slice()
console.log(str1) // abcdefg
var str2 = str.slice(4)
console.log(str2) // efg
var str3 = str.slice(2, 4)
console.log(str3) // cd
```

## 8.3 indexOf()

作用：查找指定字符串位置

参数：

	1. 被检索的字符串
 	2. 偏移位置

返回值：字符串下标位置或者-1

```
var str = '今天天气不错'
var index = str.indexOf('天气', 3)
console.log(index); // -1
```

## 8.4 charAt()

作用：查找指定位置的字符

参数：下标数字

返回值：就是被查找到的字符

```
var str = '今天天气不错'
var c = str.charAt(3)
console.log(c); // 气
```

## 8.5 toUpperCase()

作用：转大写

返回值：大写后的字符串

```
// toUpperCase方法
var str = 'aAbBcCdD'
console.log(str.toUpperCase()) // AABBCCDD
```

## 8.6 toLowerCase()

作用：转小写

返回值：小写后的字符串

```
// toLowerCase方法
var str = 'aAbBcCdD'
console.log(str.toLowerCase()) // aabbccdd
```

## 8.7 split()

作用：将字符串按照指定的规则切割成数组

返回值：数组

```
// split()
var str = '1+2+3+4+5+6+7'
var arr = str.split('+')
console.log(arr) // ["1", "2", "3", "4", "5", "6", "7"]
```

## 8.8 replace()

作用：替换

参数：

	1. 被替换下的字符串
 	2. 替换上的字符串

返回值：替换完成的字符串

```
var str = '吃了吗？'

var str1 = str.replace('吃', '干饭') 

console.log(str1) // 干饭了吗？
```

## 8.9 substring()

作用： 截取

参数：

 	1. 开始位置(包含)
 	2. 结束位置(不包含)

返回值：截取后的字符串 

> 如果第一个参数大 第二个参数小 总是从小的截取到大的

## 8.10 substr()

作用：截取

参数：

	1. 开始位置
 	2. 要截取的长度

返回值：截取的字符串

## 8.11 match()

作用：匹配

参数：

	1. 被匹配的字符串或者正则

返回值：数组



# 九、事件

浏览器设计的一套处理用户行为的机制。

所谓的事件，是浏览器监听用户行为的一种机制。

​	1.  当用户使用鼠标 `点击` 一个按钮，会触发该按钮的 `点击` 事件 如果此时我们想要执行代码 就可以事先设置JS脚本 `点击` 事件的处理函数

	2. 用户鼠标双击一个按钮，会触发该按钮的双击事件 
 	3. ...

## 9.1  事件的分类

+ 鼠标事件

  + click 点击事件
  + dblclick 双击事件
  + mousedown 鼠标按下事件
  + mouseup 鼠标抬起事件(一次click包含一次mousedown和 一次mouseup)
  + mouseover 鼠标进入事件
  + mouseenter 鼠标进入事件
  + mouseout 鼠标离开事件
  + mouseleave 鼠标离开事件
  + mousemove 鼠标移动事件
+ 键盘事件
  + keydown 键盘键被按下
  + keyup  键盘键被松开
  + keypress 输入
+  浏览器的事件
  + load 页面中所有资源都被加载完毕的时候
  + scroll 页面的卷动
  + resize 页面尺寸发生变化
+  表单元素事件
  + focus 当一个元素获取到焦点时
  + blur 当一个元素失去焦点时
  + change 当一个表单元素内容改变并失去焦点时
  + input 当一个表单元素内容有输入时 
  + submit 当一个表单元素被提交时
  + reset  当一个表单被重置时
  
+ 移动端事件
  + touchstart 触摸开始事件 会在手指按下的时候触发
  + touchmove  触摸并移动 会在手指按下并移动的时候触发
  + touchend  触摸结束事件 会在手指离开的时候触发

+ 其它事件
  + animationstart 动画开始时触发 
  + animationend  动画结束时触发
  + transitionstart 过渡开始时触发
  + transitionrun 过渡中触发 
  + transitioncancel 过渡取消时触发
  + transitionend  过渡结束时触发

## 9.2 事件的组成

+ 元素（也叫作事件源）

+ 事件类型（类型，见9.1）

+ 事件处理函数（事件函数）

## 9.3 事件流程

+ 事件冒泡：当点击时 事件从最精确的元素 一层一层往上触发 直到最顶层元素 这个过程叫做事件冒泡
+ 事件捕获：当点击时 事件从最顶层元素 一层一层的往下触发 直到最精确元素 这个过程叫做事件捕获
    + 最精确元素： 鼠标点到谁 谁就是最精确元素
    + 最顶层元素： 
        + 高级浏览器    最顶层元素是window  
        + IE中          最顶层元素是 document

## 9.4 事件对象

当事件触发的时候 会产生很多的信息 这些信息被封装成一个对象 并传递到事件处理函数中

```JavaScript
div.onclick = function(e) {
    //  e 就是事件对象 我们可以根据它获取到许多的信息 兼容性有问题 
    var e = e || window.event;
}
```

**鼠标事件的重要属性**

+ altKey  热键alt键
+ ctrlKey 热键ctrl键
+ shiftKey 热键shift键
以上属性都是布尔值，表示是否按下，没有按下为false，按下为true

+ offsetX 事件发生时鼠标位于元素内部的left位置(从鼠标位置到左边框内)
+ offsetY 事件发生时鼠标位于元素内部的top位置(从鼠标位置到上边框内)
+ clientX 事件发生时鼠标到视口的左边距离
+ clientY 事件发生时鼠标到视口的上边距离
+ pageX 事件发生时鼠标到页面的左边距离(IE中无该属性,因为有版心的缘故，通常e.clientX就是e.pageX)
+ pageY 事件发生时鼠标到页面的上边距离(IE中无该属性,可以通过e.clientY + 页面卷动值来获取)
+ currentTarget 绑定事件的元素(IE中没有该属性)
+ target 触发事件的元素(IE中没有该属性，而是叫做 srcElement)

**键盘事件的重要属性**

+ key 表示当前的键对应的字符
+ keyCode 表示当前的键对应的字符的ASCII码



## 9.5 阻止冒泡

+ 高级浏览器中 可以通过e.stopPropagation() 进行阻止事件的冒泡 

    ```JavaScript 
    // 高级浏览器中
    // box1是box2的父元素
    var box1 = document.querySelector(".box1");
    var box2 = document.querySelector(".box2");

    box1.onclick = function() {
        console.log("这是BOX1");
    }
    box2.onclick = function(e) {
        e.stopPropagation();
        console.log("这是BOX2");
    }
    ```
+ IE浏览器中 可以通过e.cancelBubble = true 进行阻止事件的冒泡
     ```JavaScript
     // IE浏览器中
     // box1是box2的父元素
     var box1 = document.querySelector(".box1");
     var box2 = document.querySelector(".box2");

     box1.onclick = function() {
         console.log("这是BOX1");
     }
     box2.onclick = function(e) {
         var e = e || window.event;
         e.cancelBubble = true;
         console.log("这是BOX2");
     }
    ```

## 9.6 停止默认行为
浏览器的一些事件中，带有一些默认行为 比如a标签的点击事件中 会带有跳转页面的行为 表单的点击事件中 带有提交的默认行为 滚轮事件中 带有改变页面卷动值的默认行为
+ 高级浏览器中 可以通过 e.preventDefault() 阻止默认行为

    ```JavaScript
    // 获取元素
    var a = document.getElementsByTagName("a")[0];
    // 设置点击事件
    a.addEventListener("click", function(e) {
        console.log("点击了a标签1111");
        e.preventDefault();
    }, false);
    ```
+ IE浏览器中 可以通过 e.returnValue = true; 阻止默认行为

    ```JavaScript
    // 获取元素
    var a = document.getElementsByTagName("a")[0];
    // 设置点击事件
    a.attachEvent("onclick", function(e) {
        console.log("点击了a标签1111");
        e.returnValue = false;
    });
    ```
+ DOM0级事件绑定方式中，可以通过**return false**进行阻止默认行为

     ```JavaScript
     // 获取元素
     var a = document.getElementsByTagName("a")[0];
     // 设置点击事件
     a.onclick = function() {
         return false;
     }
    ```

## 9.7 事件绑定


+ DOM0级
    + 绑定
        + 元素.on事件类型 = 事件函数
        + 只能够绑定一个事件 因为它是对属性进行赋值 

    + 移除
        + 元素.on事件类型 = null

> 我们都知道，一个对象的属性只能够保存一个值。 如果对一个对象属性进行多次赋值，后面赋值的属性会替换掉前面的属性

+ DOM2级
    + 绑定
        + dom.addEventListener(type, handler, boolean)
            + type: 事件类型字符串 不带on
            + handler: 事件处理函数 
            + boolean: 布尔值 决定绑定到捕获阶段还是冒泡阶段 默认是false false表示冒泡
    + 结论： 可以通过addEventListener方法进行多个事件函数的绑定 执行时是按照代码的书写顺序执行 因为代码的书写顺序决定了绑定顺序

    + 移除
        + document.removeEventListener(type, handler, boolean);
            + type: 事件类型字符串 不带on
            + handler: 事件处理函数 一定要保证函数地址是绑定的那个
            + boolean: 布尔值 决定移除的是捕获阶段还是冒泡阶段 默认是false false表示冒泡
    + > 结论： 第二个参数是要移除的函数 函数是引用类型 引用类型的比较的是地址 所以一定要保证 **移除的函数是当初绑定的那个函数本身** 

+ IE中的高级绑定方式(非DOM2级)

    + 绑定方式：
        + dom.attachEvent(type, handler);
            + type: 事件类型字符串 带on 
            + handler: 事件处理函数
            + 没有第三个参数 意味着不能够绑定到捕获阶段
            特点: 可以对同一个元素绑定多个同类型事件的处理函数 执行起来是倒着执行 先绑定的后执行 后绑定的先执行
    + 移除方式：
        + dom.detachEvent(type, handler);
            + type: 事件类型字符串 带on 
            + handler: 事件处理函数 要注意函数的地址问题

## 9.8 事件委托

事件委托也叫作事件代理。是一种设计模式。

思想： 将原本子元素做的事情，委托给父元素去做。将事件绑定给父元素，父元素事件触发时，通过e.target判定触发事件的元素。决定执行对应代码

```JS
// 1 获取元素 获取不可能被移除的父元素
var tbody = document.querySelector("tbody");
// 2 给tbody绑定事件
tbody.onclick = function(e) {
    // e.target 这个属性指向触发事件的元素
    console.log(e.target)
    // 判定 点击到的是什么  
    if (e.target.className === "del") {
        // 点击到的是移除按钮 
        e.target.parentNode.remove();
    }
}
```

## 9.9 循环绑定事件时i的问题

循环绑定事件

```
var arr = [li, li, li]; 
for (var i = 0; i < arr.length; i++) {
	arr[i].onclick = function() {
		console.log(i);
	}
}
```

点击时:![1609905172390](images/1609905172390.png)

> 发现问题：点击时因为循环已经结束，所以输出的是3。而不是预想中的 0 1 2.

可是有时候我们需要用到这个循环变量当时的值，而不是循环结束后的值。

**解决方案1： 添加自定义JS属性**

```JS
 for (let i = 0; i < arr.length; i++) {
     // 1 给每一个元素 添加一个自定义的JS属性
     arr[i].index = i;
     arr[i].onclick = function() {
     	// 再在函数中，通过this访问自定义属性
     	console.log(this.shuaindexige) 
     } 
 }
```

结果：![1609905412426](images/1609905412426.png)

**解决方案2： IIFE**

```JS
for (var i = 0; i < arr.length; i++) { 
  // 2 IIFE解决循环问题 
  (function(m) {
    arr[m].onclick = function() {
      console.log(m)
    }
  })(i)
}
```

原理如下图：

![1609903461821](images/1609903461821.png)

**解决方案3：数组的forEach方法**

```
arr.forEach(function(value, index) {
    value.onclick = function() {
    	console.log(index)
    }
})
```



# 十、内置对象

所谓的内置对象，其实就是我们打开浏览器之后就可以直接使用的对象

比如，Object、Array、String、Number、Boolean、Error、Date、RegExp 等等等等

它们有的是对象，有的是函数。

## 10.1 Math

这是一个对象，这个对象封装了与数学相关的操作。

不可以使用new运算符。

![1609139043165](images/1609139043165.png)

### 10.1.1 Math.random()

作用：求一个随机数(伪随机数)

返回值：[0~1) 之间的随机数

```JS
console.log(Math.random())
```

### 10.1.2 Math.ceil()

作用：向上取整

返回值：取整后的整数

```
 result = Math.ceil(3.9)
 console.log(result); // 4
```

### 10.1.3 Math.floor()

作用：向下取整

返回值：取整后的整数

```
 var result = Math.floor(3.9);
 console.log(result);// 3
```

### 10.1.4  Math.sqrt ()

作用：开平方根

返回值：正数平方根

```
console.log(Math.sqrt(4)) // 2
```

### 10.1.5 Math.max()

作用：取最大值

返回值：最大值数字

```JS
console.log(Math.max(1, 55, 6789, -3)) // 6789
```

### 10.1.6 Math.min()

作用：取最小值

返回值：最小值数字

```JS
console.log(Math.min(1, 55, 6789, -3)) // -3
```

### 10.1.7 Math.round() 

作用：四舍五入

返回值：整数

```
console.log(Math.round(4.5)); // 5
console.log(Math.round(4,4)); // 4
```

### 10.1.8 Math.abs()

作用：取绝对值

返回值：正数

```
console.log(Math.abs(56)); // 56
console.log(Math.abs(-56)); // 56
```



## 10.2 Date

### 10.2.1 初始化

Date是一个构造函数 用的时候 要new Date() 

**如果不传递参数 获取的是当前的时间**

```JS
var d = new Date();
console.log(d); // Mon Dec 28 2020 16:13:32 GMT+0800 (中国标准时间)
```

**传递日期格式的字符串**

```
var d = new Date('1987-09-09 23:56: 04')
console.log(d); // Wed Sep 09 1987 23:56:04 GMT+0900 (中国夏令时间)
```

**传递毫秒值 从1970年1月1号 0点0分0秒开始计算的日期**

```
var d = new Date(1000);
console.log(d) 
Thu Jan 01 1970 08:00:01 GMT+0800 (中国标准时间)
```

**传递多个参数** 

1. **年** 

 	2. **月** 
 	3. **日** 
 	4. **时** 
 	5. **分** 
 	6. **秒** 
 	7.  **毫秒**

```
var d = new Date(2020, 0, 33, 23, 45, 4, 4444);
console.log(d)
```

> 每一个数字都可以进位
>
> 月从0开始 
>
> ​	0 一月
>
> ​	1 二月
>
> ​	2 三月
>
> ​	3 四月
>
> ​	...
>
> ​	11 十二月

### 10.2.2 日期对象的方法

```
var date = new Date();  // 2020-12-29 9.30.25 
```

获取年 getFullYear()

```
var year = date.getFullYear() // 2020
```


获取月 getMonth()

```
var month = date.getMonth() // 11
```

获取日 getDate()

```
var dates = date.getDate() // 29
```

获取时 getHours()

```
var h = date.getHours() // 9
```

获取分 getMinutes()

```
var m = date.getMinutes() // 30
```

获取秒 getSeconds()

```
var s = date.getSeconds() // 25
```

获取毫秒 getMilliseconds()

```
var ms = date.getMilliseconds() // 234
```

获取星期几 getDay() 

```
var week = date.getDay(); // 2
```

获取1970年开始的时间戳

```
var time = date.getTime(); // 1609206236556
```

# 十一、BOM

Browser Object Model浏览器对象模型

它是JS的一个组成部分，主要是与浏览器相关的功能操作。

简单来说，就是window。

包含的功能有： 弹框、获取浏览器的尺寸、获取计算后样式、文档对象、历史记录、地址栏、打开、关闭窗口

## 11.1 三个弹框

window.alert 弹出警告框

window.confirm 弹出选择框

window.prompt 弹出输入框

浏览器规定“任何window的属性在使用的时候可以不写window.”

## 11.2 获取浏览器的尺寸

window.innerWidth

window.innerHeight

## 11.3  history

历史记录对象，通过它可以实现前进后退功能(页面左上角的 ← 和 →)

	1. history.forward() 前进
 	2. history.back() 后退
 	3. history.go(n) 跳转n次
      	1. n为正数 表示前进n次
      	2. n为零 表示刷新
      	3. n为负数 表示后退

## 11.4 location

地址栏对象，通过它可以实现页面的跳转

查看该对象(当前url为  https://www.baidu.com?a=1&b=2&c=3#ccc)

![1609326015883](images/1609326015883.png)

 1.  location.href   地址栏的全部字符串内容

      1.  获取当前地址栏的内容

      2.  设置新地址 

          ```
          location.href = 'https://www.baidu.com' 跳转到百度
          ```

	2. location.assign(url)  跳转方法

        	1. url 新地址 

        ```
        location.assign('https://www.baidu.com') 跳转到百度
        ```

	3. location.search  查询串部分

    ```
     location.search // ?a=1&b=2&c=3
    ```

	4. location.hash 哈西部分

    ```
    location.hash // #ccc
    ```

	5. origin 源

    ```
    location.origin // https://www.baidu.com
    ```

	6. port 端口

    ```
    location.port // 无(url中如果不写，默认是80端口)
    ```

	7. host 主机名

    ```
    location.host // www.baidu.com
    ```

	8. protocol 协议

    ```
    location.protocol // https:
    ```

    

## 11.5 open

​	window.open(url); 用于打开一个新的页面。

## 11.6  close

​	window.close(); 用于关闭当前页面(不一定关得掉)

## 11.7 getComputedStyle

​	window.getComputedStyle(dom)  获取计算后样式

​		dom: 元素

​	返回值：元素的计算后样式对象

​	![1609327112912](images/1609327112912.png)

获取元素的计算后属性

```JS
var cssObj = window.getComputedStyle(box)
console.log(cssObj.display) // 获取display属性
console.log(cssObj.backgroundColor) // css中的带-的属性 我们在js中要去掉- 并把后面的首字母转大写
console.log(cssObj['background-color']) // 或者使用方括号语法
```

​	注：只能在高级浏览器中使用

​	**解决方案：能力检测**

​	这种通过判断一个对象是否有某一个属性的方式，叫做检测对象的能力，也叫作能力检测

```JS
function getCss(yuansu, shuxing) { 
  if (window.getComputedStyle) {
    return window.getComputedStyle(yuansu)[shuxing]
  } else {
    return yuansu.currentStyle[shuxing]
  }
}
```



# 十二、定时器

## 12.1 setTimeout

作用：一定时间之后 执行函数

参数：

	1. 被执行的函数
 	2. 延迟时间 它是一个数字 单位是毫秒

demo:

```
setTimeout(function() {
  console.log(1);
}, 3000)
```

效果：3秒之后，输出1

## 12.2 setInterval

作用：让一个函数按照时间循环执行

参数：

	1. 被执行的函数
 	2. 间隔时间

demo: 

```
// 每1秒输出这条代码
setInterval(function () {
  var now = new Date()
  var newYear = new Date('2021-01-01 0:0:0')
  var xiangchahaomiaozhi = newYear - now;
  var miao = xiangchahaomiaozhi / 1000;
  var fen = miao / 60;
  var xiaoshi = fen / 60;
  var tian = xiaoshi / 24;
  document.body.innerHTML = "<h1>" + ("现在距离元旦还有" + parseInt(tian) + "天" + parseInt(xiaoshi % 24) + "小时" + parseInt(fen % 60) + "分" + parseInt(miao % 60) + "秒") + "</h1>"
}, 1000)
```

作用：每一秒都生成一个时间并显示在body中





# 十三、DOM

Document Object Model (文档对象模型)

有一些元素是不需要获取就可以快速使用的。

```JS
body: document.body
html: document.documentElement
head: document.head
title: document.title // 这不是元素 而是一个属性
forms: 这个文档中所有form的集合
form.elements 一个表单中的所有控件元素(控件：指的是input、select、textarea等)
```



## 13.1 获取元素

在JS中操作元素，必须要先获取到元素

- 根据ID获取元素

    - document.getElementById(id)
    该方法用于根据ID获取元素 ID是HTML标签的属性 应当具备唯一性
    - 返回值：如果有这个元素 就可以得到该元素对象。如果没有，就是null。
- 根据标签名获取元素

    - document.getElementsByTagName(tagName)
    - 返回值： 集合对象(类数组对象)
- 根据name属性获取元素 

    - document.getElementsByName(name)
    - 返回值： 集合对象(类数组对象)
- 根据class属性获取元素
    - document.getElementsByClassName()
- 根据选择器获取元素

    - document.querySelector(selector)
    - 返回值： 元素对象
- 根据选择器获取多个元素

    - document.querySelectorAll(selector);
    - 返回值： 集合对象(类数组对象)

## 13.2 元素属性

可以分为HTML标准属性与非标准属性(自定义属性)

+ 标准属性 指的是由W3C制定的属性 
  + 通用属性 所有标签都有的属性 
    + id 
    + class 
    + style 
    + title
  + 特有属性 只有一个或者几个标签有的属性 
    + name
    + type
    + checked
+ 非标准属性 指的是由程序员自己定义的属性
  + 通常以`data+`开头

## 13.3元素的基本操作

+ 标准属性
  可以直接通过元素打点获取 打点修改 (或者使用方括号语法也可以) **注意避讳关键字**

```JavaScript
// 避讳JS中的class关键字
dom.className = "abc";
// 读取name属性值
var str = input.name;
```

+ 非标准属性
  + setAttribute(propName, propValue); 设置、修改属性值
    + propName 属性名
    + propValue 属性值
  + getAttribute(propName) 获取属性值
    + propName 属性名
  + removeAttribute(propName) 移除属性(从HTML标签身上移除)
    + propName 表示属性名

## 13.4 节点

一个文档中，都由各种节点组成。

最重要的是元素.

总共12种，我们需要记忆的有5种。

1. 元素节点

 	2.  属性节点
 	3.  文本节点
 	4.  略
 	5.  略
 	6.  略
 	7.  略
 	8.  注释节点
 	9.  文档节点
 	10.  略
 	11.  略
 	12.  略

##  13.5 节点属性

**nodeType节点类型** 

```
 console.log(div.nodeType) 1
 console.log(id.nodeType) 2
 console.log(textNode.nodeType) 3
 console.log(commentNode.nodeType) 8
 console.log(document.nodeType) 9
```

**nodeName节点名称**

```
console.log(div.nodeName)  // 元素大写的名字  DIV A P UL LI等
console.log(id.nodeName)  // 属性名 id class 等
console.log(textNode.nodeName) // #text  
console.log(commentNode.nodeName) // #comment
console.log(document.nodeName) // #document
```

**nodeValue节点值**

```
console.log(div.nodeValue)   // null
console.log(id.nodeValue)   // 属性值 
console.log(textNode.nodeValue) // 文本内容
console.log(commentNode.nodeValue) // 注释内容
console.log(document.nodeValue)  // null
```

## 13.6 节点关系

节点关系只有两种：兄弟、父子

**兄弟关系**

1. previousSibling 前一个兄弟节点

 	2. nextSibling 下一个兄弟节点

**父子关系**

父找子：

1. childNodes 所有子节点集合   

 	2. firstChild 第一个子节点
 	3. lastChild 最后一个子节点

子找父：

​	1. parentNode

## 13.7 元素操作

就是操作元素的方式

**创建**

 	1. 创建元素  
      	1. document.createElement(labelName)
           	1. labelName  标签名字符串
 	2. 创建文本
      	1. document.createTextNode(str);
           	1. str   文本字符串
 	3. 注释
      	1. document.createComment(str);
           	1. str 文本字符串
 	4. 文档碎片
      	1. document.createDocumentFragment();

```
var element = document.createElement('li');
console.log(element);
// 创建文本节点
var text = document.createTextNode('今天是个好日子');
console.log(text);
// 创建注释节点
var comment = document.createComment('今天是个好日子')
console.log(comment)
// 创建文档碎片
var documentFragment = document.createDocumentFragment();
console.log(documentFragment)
```

**上树**

父节点.appendChild(子节点)

**下树**

父节点.removeChild(子节点)

子节点.remove()

**插入**

父节点.insertBefore(子节点1， 子节点2)  

把子节点1插入到子节点2之前

**替换**

父节点.replaceChild(子节点1，子节点2)

用子节点1来替换掉子节点2

**克隆**

节点.cloneNode(bool)

如果bool为真 连带子节点一起克隆 如果为假 只克隆自己

##  13.8 快捷尺寸

1. clientWidth 获取内容宽与左右padding之和
2. clientHeight 获取内容高与上下padding之和
3. offsetWidth 获取内容宽与左右padding与左右border宽度之和
4. offsetHeight 获取内容高与上下padding与上下border宽度之和
5. clientLeft 左边框宽度
6. clientTop 上边框宽度
7. scrollTop、window.scrollY 页面上方的滚动条高度

```CSS
div {
    width: 100px;
    height: 50px ;
    padding: 20px;
    border: 20px solid red;
}
```

```JS
var div = document.getElementById("div");

console.log(div.clientWidth); // 输出 140px 

console.log(div.clientHeight); // 输出 90px 

console.log(div.offsetWidth); // 输出 180px 内容宽 100 + padding 40 + border 40

console.log(div.clientWidth); // 输出 130px 内容高 50 + padding 40 + border 40
```

## 13.9 快捷位置

 	1. offsetParent 定位父元素 
      	1. 指的是自身元素相对于的定位元素 如果一个元素自身没有定位 也会找到祖先元素中的第一个拥有定位的元素 如果都没有 就是body
 	2. offsetLeft 自己左边框外到定位父元素的左边框内 (IE8 到定位父元素的左边框外)
 	3. offsetTop 自己上边框外到定位父元素的上边框内 (IE8 到定位父元素的上边框外)

![images/2012110117044039.gif](images/2012110117044039-1609754283874.gif)

# 十四、ES5


## 14.1 严格模式
    因为JS是一门很随心 很随意的语言 而且设计之初遗留了很多不好的地方 这就给开发人员制造了很多困扰 而且也有开发人员给开发人员制造的困扰
    为了解决这些问题 ES5 中 增加了一个 "严格模式" 严格要求开发人员的代码书写
**开启严格模式**

在当前作用域的第一行 使用字符串 `use strict`;
+ 全局严格模式、局部严格模式

  ```JS
  <script> 
    // 开启严格模式 要求：必须在当前作用域的第一行(除了注释之外)  作用域分全局和局部 严格模式也就分了全局和局部
    'use strict';
    ...
    
  
  
    // 局部严格模式
    var a = function () {
      'use strict';
      c = 10;
    }
    b = 10;
    a();
  </script>
  ```

  

+ 声明变量必须使用var  

  ```JS
  'use strict';  
  // 1 严格模式下 声明变量必须用关键字
  a = 10;
  console.log(a); // a is not defined
  ```

  

+ 函数的形参不可以重名

  ```JS
  'use strict'; 
  function demo(a, a, b, c) {
      console.log(a, b, c);
  } 
  demo(1, 2, 3, 4) 
  // Uncaught SyntaxError: Duplicate parameter name not allowed in this context
  ```

  

+ 不可以使用八进制

  ```JS
  'use strict';
  // 定义八进制
  var num = 0123;
  console.log(num) 
  // Uncaught SyntaxError: Octal literals are not allowed in strict mode.
  ```

+ 不可以使用保留字作为变量名

  ```JS
  'use strict';
  var interface = 1;
  console.log(interface)
  //  Uncaught SyntaxError: Unexpected strict mode reserved word
  ```

+ eval 

  ```JS
  // eval是一个函数 它可以把字符串当做代码执行
  var num = eval('1 + 2');
  console.log(num) // 3
  ```

  ```JS
  'use strict';
  eval("var a = 10; console.log(a)"); // 在严格模式下 eval依然可用 但是会形成一个独立的作用域
  console.log(a)
  ```

+ 不能删除变量

  ```JS
  'use strict';
  var a = {
    b: 1
  }
  console.log(delete a); 
  // Uncaught SyntaxError: Delete of an unqualified identifier in strict mode. 
  ```

+ 不能用arguments.callee

  ```JS
  'use strict';
  function demo() {
    console.log(arguments.callee === demo) // true
    console.log(arguments.callee) // 指向的是当前的函数本身 
  }
  demo();
  
  // Uncaught TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them
  ```

+ 不能用with

  ```JS
  'use strict';
  
  var obj = {
    name: "小明",
    age: 13,
    sex: "女",
    hehe: "呵呵呵呵呵"
  }
  
  var hehe = 'aaaa'
  
  with(obj) {
    console.log(name)
    console.log(age)
    console.log(sex)
    console.log(hehe)
  } 
  // Uncaught SyntaxError: Strict mode code may not include a with statement
  ```

  
## 14.2 数组方法

### 14.2.1 forEach

arr.forEach(handler)

​	handler(value, index, self): 处理函数

​		value: 成员

​		index: 索引

​		self: 原数组

```JS
var arr = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
arr.forEach(function(value, index, self) {
  console.log(value, index, self)
})
```

输出

![1609835425283](images/1609835425283.png)

### 14.2.2 map

arr.map(handler)

​	handler(value, index, self): 处理函数

​		value: 成员

​		index: 索引

​		self: 原数组 

返回值：新数组 取决于handler的返回值

```JS
var arr = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
var arr1 = arr.map(function (value, index, self) {
  return value + "1";
})
console.log(arr1)
```

![1609835829556](images/1609835829556.png)

### 14.2.3 filter

arr.filter(handler)

​	handler(value, index, self): 处理函数

​		value: 成员

​		index: 索引

​		self: 原数组 

返回值：新数组 取决于handler的返回值

```JS
var arr = [
  { type: "大菜", name: "鱼香肉丝", price: 10 },
  { type: "大菜", name: "红烧肉", price: 10 },
  { type: "大菜", name: "香辣粉", price: 10 },
  { type: "中菜", name: "小炒肉", price: 13 },
  { type: "中菜", name: "云吞", price: 14 },
  { type: "小菜", name: "雪糕", price: 15 },
  { type: "小菜", name: "黄瓜", price: 16 }
]

var arr1 = arr.filter(function(value) {
  return value.price < 13
})
console.log(arr1)
```

输出：

![1609836255042](images/1609836255042.png)

### 14.2.4 some

arr.some(handler)

​	handler(value, index, self): 处理函数

​		value: 成员

​		index: 索引

​		self: 原数组 

返回值：布尔值  取决于handler的返回值，如果有任何一个符合条件的，为真，都不符合，为假。

```JS
var arr = [
  { type: "大菜", name: "鱼香肉丝", price: 10 },
  { type: "大菜", name: "红烧肉", price: 10 },
  { type: "大菜", name: "香辣粉", price: 10 },
  { type: "中菜", name: "小炒肉", price: 13 },
  { type: "中菜", name: "云吞", price: 14 },
  { type: "小菜", name: "雪糕", price: 15 },
  { type: "小菜", name: "黄瓜", price: 16 }
]

// 判断有没有价格小于13的
var result = arr.some(function (value) {
  return value.price < 13
})
console.log(result)
```

输出结果<img src="images/1609836495083.png" alt="1609836495083" />

### 14.2.5 every

arr.every(handler)

​	handler(value, index, self): 处理函数

​		value: 成员

​		index: 索引

​		self: 原数组 

返回值：布尔值  取决于handler的返回值，如果全部符合条件的，为真，有任一不符合，为假。

```
var arr = [
  { type: "大菜", name: "鱼香肉丝", price: 10 },
  { type: "大菜", name: "红烧肉", price: 10 },
  { type: "大菜", name: "香辣粉", price: 10 },
  { type: "中菜", name: "小炒肉", price: 13 },
  { type: "中菜", name: "云吞", price: 14 },
  { type: "小菜", name: "雪糕", price: 15 },
  { type: "小菜", name: "黄瓜", price: 16 }
]

// 判断是否全部价格都小于13
var result = arr.every(function (value) {
  return value.price < 13
})
console.log(result)
```

输出结果：![1609836645296](images/1609836645296.png)



### 14.2.6 reduce

arr.reduce(handler, init)  累计方法

​	handler(prev, value, index, self)

​		第一个参数是上一个handler返回的值

​		第二个参数是成员

​		第三个参数是索引

​		第四个参数是原数组

​	init handler第一次执行时的prev

返回值：最后一个handler执行的返回值

```JS
var arr = [
  { type: "大菜", name: "鱼香肉丝", price: 10 },
  { type: "大菜", name: "红烧肉", price: 10 },
  { type: "大菜", name: "香辣粉", price: 10 },
  { type: "中菜", name: "小炒肉", price: 13 },
  { type: "中菜", name: "云吞", price: 14 },
  { type: "小菜", name: "雪糕", price: 15 },
  { type: "小菜", name: "黄瓜", price: 16 }
]
var result = arr.reduceRight(function(prev, value) {
  console.log(value)
  return prev + value.price;
}, 0)
console.log(result / 7) 
```

均价：![1609837704132](images/1609837704132.png)

### 14.2.7 reduceRight

同reduce，只是从数组的末尾开始运算。

## 14.3 函数方法

函数也是引用类型，也可以调用方法。

### 14.3.1 call

函数.call(target, ...)

​	target: 新的this

​	后续参数是原函数所需的参数

```JS
function demo(a, b) {
  console.log(this);
  console.log(a, b) 
}
demo.call(document.body, 1, 2)  // document.body
demo.call(document, 1, 3)  // document
demo.call(document.documentElement, 1, 4) // document.documentElement
```

### 14.3.2 apply

函数.apply(target, arr)

​	target: 新的this

​	arr: 数组，数组中的每一个值是原函数所需的参数，按照顺序排列

```JS
function demo(a, b) {
  console.log(this);
  console.log(a, b) 
}
demo.apply(document.body, [1, 2])  // document.body
demo.apply(document, [1, 3]) // document
demo.apply(document.documentElement, [1, 4]) // document.documentElement
```



> 总结： 
>
> call和apply都是ES5之前的方法
>
> 作用 都是执行函数并改变函数的this指向
>
> 不同：参数的传递方式不同 call是通过平铺的方式传递 而apply是以数组的方式传递

### 14.3.3 bind

ES5中新增的方法

函数.bind(target, item1, item2, ...)

​	target: 新的this

​	后续参数都是预传递的参数 

返回值：一个新的函数 

```
var demo1 = demo.bind({name:"xiaoming"});
// bind并不是把原函数中的this给改掉的，而是返回了一个新的函数 让新函数的this是指定的this 但是执行的内容与原函数一致
demo1() // {name:"xiaoming"}
demo1() // {name:"xiaoming"}
demo1() // {name:"xiaoming"}
demo1() // {name:"xiaoming"}
demo1() // {name:"xiaoming"}
demo1() // {name:"xiaoming"}
```

> bind与前两个方法的不同之处在于bind的调用并不会立刻导致函数的执行。而是返回一个新的函数。

## 14.4 JSON

JavaScript Object Notation JS对象表达式

JSON是一种数据格式，它严格要求：

1. 每一个属性名必须由双引号包裹

    	 2. 每一个字符串必须由双引号包裹
             	 3. 不能有注释
            	 4. 最后一个逗号必须省略

ES5中，新增了一个JSON对象。 

 	1. stringify(object | arr) 
      	1. 参数是对象或者数组
      	2. 返回值 JSON字符串
 	2. parse(JSONString)
      	1. 参数是JSON字符串
      	2. 返回值 是对象或者数组

> parse方法接受的参数如果不是合格的JSON字符串，则会报错

如图所示  <img src="images/1609848927503.png" alt="1609848927503" style="zoom:300%;" />

# 十五、正则表达式

正则表达式是一组用于检测字符串是否符合某种规则的表达式。

## 15.1 定义


- 字面量定义 /正则表达式/修饰符
    - /\d+/g
- 构造函数定义 RegExp(正则表达式, 修饰符);
    - new RegExp("abc", g)
        - 第一个参数是正则表达式的表达体
        - 第二个参数是正则表达式的修饰符
          - g  global 表示全局匹配
          - i   ignore 表示忽略大小写
          - m multiple 表示多行匹配

## 15.2 组成

+ 普通字符 a b c d e f g ....    1 2 3 4 5 ....  赵、钱、孙、李....


- 转义字符
    - \d 所有的数字
    - \D 所有的非数字
    - \w 所有的数字字母下划线
    - \W 所有的非数字字母下划线
    - \s 所有的空白符
    - \S 所有的非空白符
- 特殊字符(元字符)
    - . 除了回车和换行之外的其它所有内容
    - () 分组 分组内是一个整体
    - [] 范围 
        - [a-z]
        - [A-Z]
        - [0-9]
        - [0-9A-Za-z]
    - {} 数量
        - {10} 限定十个 不能多也不能少
        - {3,5} 最少三个 最多五个
        - {1,} 最少一个 最多无穷个
    - ?  零个或一个
    - \+ 一个或任意个
    - \* 零个或任意个
    - | 或者
    - ^ 开头
    - $ 结尾

## 15.3 字符串方法replace

- replace(drop, add);
    - drop 被替换下的内容
        - 可以是字符串 
        - 可以是正则表达式
    - add 被替换上的内容
        - 可以是字符串
        - 可以是函数
            - 函数的返回值是被替换上的内容
            - 函数的参数
                - 第一个表示匹配到的内容
                - 第二个表示匹配到的内容的索引
                - 第三个表示原字符串
                - 如果正则表达式中有圆括号，则圆括号捕获的内容会一一对应放在第二个参数位置及后面位置 原来的第二个参数和第三个参数会向后推移

```
1 有如下字符串：
	var str = '<table><tr><td id="u{{id}}">{{id}}</td></tr><td title="{{name}}">{{name}}</td></table>';
  结合对象： var user = {id: "1234", name: "tony"};
  变为： <table><tr><td id="u1234">1234</td></tr><td title="tony">tony</td></table>
2 有如下字符串
    var url = "cid=123&type=image&startTime=2017";
    请写一个函数，传入url，返回如下对象
    {cid: 123, type: "image", startTime: 2017}
```


第一题：
```
var str = '<table><tr><td id="u{{id}}">{{id}}</td></tr><td title="{{name}}">{{name}}</td></table>';
var user = { id: "1234", name: "tony" };

// 正则分组捕获
var str1 = str.replace(/{{(\w+)}}/g, function(match, $1) {
  // match 正则匹配到的字符串
  // $1 圆括号匹配到的部分
  console.log(match, $1)
  return user[$1];
})
console.log(str1)
```

输出：

![1609922694477](images/1609922694477.png)

# 十六、ES6

## 16.1 块级作用域
- ES6中的块级作用域 指的是 **{}** 之间可以生成作用域
## 16.2 let关键字
通过let定义的变量 遵循ES6的块级作用域规范

- 块级作用域
```JavaScript
if (true) {
    var a = 10;
    let b = 11;
    console.log(a); // 10
    console.log(b); // 11
}
console.log(a); // 10
console.log(b); // 报错
```
- 没有变量声明的提升
```JavaScript
console.log(a);  // undefined 因为声明提升
var a = 10;
console.log(b); // 报错
let b = 11; 
console.log(b);
```
- 不可以重复定义同名变量
```JavaScript
var a = 10;
var a = 11;
console.log(a); // 可以输出11

let a = 10;
let a = 11; // 报错 Uncaught SyntaxError: Identifier 'a' has already been declared
```

- let定义的变量不会自动注册到window身上
```JavaScript
var a = 10; // var出来的全局变量会被自动注册成window的属性
console.log(window.a); // 10

let a = 10; 
console.log(a); // 10
console.log(window.a); // undefined

console.log(a); // 在不声明a时 会报错
console.log(window.a); // 有就用 没有就undefined 
```
- for循环的不同
```JavaScript
var arr = new Array(5).fill(0);
for (let i = 0; i < arr.length; i++) {
    arr[i] = function() {
        console.log(i);
    }
}
// 如果上面定义循环变量i时使用的是var 则下面代码执行时都输出5 如果用let定义变量 则如下执行
arr[0](); // 0
arr[1](); // 1
arr[2](); // 2
arr[3](); // 3
arr[4](); // 4
```
## 16.3 const关键字 
用于定义常量 
命名规范: 推荐全部大写 如果出现了单词需要使用_进行分割
ex: const HELLO_WORLD = 10;

- 值一旦被赋值 不能使用等号改
```JavaScript
const A = 10;
A = 11; // 报错: Uncaught TypeError: Assignment to constant variable.
/* 如果常量保存的是引用类型 可以使用方括号语法和点语法进行属性的修改 */
const OBJ = {};
OBJ = 123; // 会报错
OBJ["hello"] = 123;
```
> 注：const定义的常量也遵守块级作用域 也没有声明提升 也不会注册到window身上 千万不要使用const来定义循环变量

## 16.4 对象的定义简化
​	ES6中 针对对象的定义 进行了语法上的简化
- 如果对象的属性名和属性值一致  则可以只使用一个
```JavaScript
/* 以前的定义变量 */
var color = "red"; 
var obj = {
    color: color
}

// 简化后
var obj = {
    color
}
console.log(obj);
```

- 现在可以在对象属性定义时通过方括号进行开辟JS执行环境
```JavaScript
var he = "he";
var llo = "world";
var obj = {
    hello: "",
    [he + llo]: ""
}
```

- 定义方法时 可以省略 : function
```JavaScript
var obj = {
    a: 1,
    hello: function() {
        console.log("hello");
    },
    world() {
        console.log("world");
    }
}
console.log(obj.a);
obj.hello(); // hello
obj.world(); // world
```

## 16.5 解构语法
提到解构，就不得不提封装
- 封装 封装指的是将内容包装在一起 
    - 代码封装  使用函数
    - 数据封装  使用数据结构  目前为止我们学习的数据结构一共有两种 分别是数组和对象

- 解构 指的是解除构造\解除结构(换句话说就是，你封装的，我给你拆了)

### 16.5.1 解构数组
- 人工解构
```JavaScript
// 定义数组
var arr = [1, 2, 3, 4, 5];
// 人工解除结构
var a = arr[0];
var b = arr[1];
var c = arr[2];
var d = arr[3];
var e = arr[4];
```
- ES6语法解构
```JavaScript
// 定义数组
var arr = [1, 2, 3, 4, 5];
// 解构语法
var [a, b, c, d, e] = arr;
```

### 16.5.2 解构对象
- ES6语法解构
```JavaScript
// 解构对象
var obj = {
    username: "zhangsan",
    password: "123321",
    dog: {
        name: "xiaobai"
    }
}
var {password, username, dog} = obj;
console.log(username, password, dog);
```
> 注: 数组解构，是用下标一一对应，所以要注意顺序。 对象解构，是使用属性名对应，所以不用注意顺序，但是要注意属性名是否对应。

## 16.6 多行字符串
也叫作字符串模板

在ES6之前 所有的字符串只能是单行字符串 单引号与双引号定义的都是单行

- 定义语法
    - ES6定义多行字符串方式  **``** 
    - 按键位置： 横向数字键1左侧 tab键上侧 esc键下方
- 插值语法
  - ${}
注: ${}内是一个JS执行环境，可以放变量，可以放表达式，可以调用方法

```JavaScript
var str = `
    <div>
    	<div class="box1">${username}
        </div>
        <div class="box1">${password}
        </div>
        <div class="box1">${email}
        </div>
    </div>
`;
```
## 16.7 函数中的this
function定义的函数中的this，是可以变化的，遵循的规则是： 谁调用就指向谁， 如果没有明确的调用者，则指向window
- 会变化的this
```JavaScript 
function demo() {
    console.log(this);
}

// 自己执行 
demo(); // window

document.onclick = demo; // document

var obj = {
    demo
}

obj.demo(); // obj

setInterval(demo, 1000); // window
setTimeout(demo, 1000); // window
```

### 16.7.1 改变函数中this指向的方法
这三个都是函数的方法 
- call
    call可以调用函数  它的作用是执行函数并改变函数中的this指向   如果原函数需要参数 需要往call的参数列表中传递 第一个参数是this 往后的每一个参数是原函数所需参数

```JavaScript
function sum(a, b) {
    console.log(this);
    console.log(a, b);
}

sum.call(); // 不传递参数时 this指向window a和b 都是undefined
sum.call(document);//  this指向了document a 和 b都是undefined
sum.call(document.body, 1);// this指向body a时1 b是undefined
sum.call(document.body, 1, 3);// this指向body a时1 b是3
```
- apply
    apply可以调用函数 它的作用是执行函数并改变函数中的this指向   如果原函数需要参数 需要往apply的参数列表中传递 第一个参数是this  第二个参数是数组 数组中的每一个成员是原函数所需的参数 按照数组顺序一一对应
```JavaScript
function sum(a, b) {
    console.log(this);
    console.log(a, b);
}
sum.apply(); // 不传递参数时 this指向window a和b 都是undefined
sum.apply(document); // this指向了document a 和 b都是undefined
sum.apply(document, [1]); // this指向了document a 是 1 b 是undefined
sum.apply(document, [1, 3]); // this指向了document a 是 1 b 是 3
```
- bind
    bind 是ES5中新增的方法 作用是在定义的时候改变this指向(其实是返回了一个新的函数)
```JavaScript
function sum(a, b) {
    console.log(this);
    console.log(arguments);
}
// 调用bind方法
var fun = sum.bind(document, 1, 2, 0.4, 0.5, 0.6);
// fun是一个函数 
fun(3, 4, 5, 6, 7);
console.log(sum === fun); // false
```
## 16.8 箭头函数
ES6中新增的一种函数定义方式
箭头函数 **var name = () => {}**

- demo
```JavaScript
var fun = () => {
    console.log("hello 我是一个箭头函数");
}
fun(); // hello 我是一个箭头函数
console.log(typeof fun); // function
```
- 箭头函数中的this
    箭头函数中的this 只有在定义箭头函数时能够确定 而且一旦确定再也不会更改 
```JavaScript
let fun = () => {
    console.log(this);
}
fun(); // window
document.onclick = fun; // 依然是window
let obj = {
    fun
}
obj.fun(); // window
fun.call(document.body); // window
fun.apply(document.documentElement); // window
var fun1 = fun.bind(document);
fun1(); // window
```
> 总结：经过各种测试 我们发现无论如何 箭头函数中的this是不会发生变化的 

- 函数的参数默认值
  
```JavaScript
function fun(a = [], b = {}) {
    console.log(a, b);
}
fun(); // 不传递参数 但是因为在定义形参时 通过赋值语法进行了默认值的赋值 所以依然可
fun(0); // 一旦传递了参数 不论传递的是什么 传递了值的参数 将不会再使用默认值
fun("a0", "b1"); 
```

- 函数中没有arguments

```JavaScript
let fun = () => {
    console.log(arguments); 
}
fun(); // 报错 
```

- 箭头函数的简写形式
    - 如果参数只有一个 那么可以省略圆括号
    - 如果函数体中只有一条代码并且还是返回值 则可以省略大括号 和return  
```JavaScript
var fun = x => x * x * x * x;
var result = fun(5);
console.log(result); // 625
```

## 16.9 拓展语法(...)
- 作用1 作为函数的参数收集器
  
```JavaScript
// ...语法作用之一： 获取参数为数组
let fun = (...a) => {
    console.log(a);
}
fun(); 
fun(1); 
fun(1, 2); 
fun(1, 2, 3); 
```

- 作用2 解构时使用

```JavaScript
var arr = "abcdefg".split("");
console.log(arr); // ["a","b","c","d","e","f","g"]
var [a,b,c, ...d] = arr;
console.log(a, b, c); // a b c
console.log(d); // ["d","e","f","g"]
```

- 作用3 传递参数时使用

```JavaScript
var arr = "abcdefg".split("");
var [a,b,c, ...d] = arr;
console.log(arr);
console.log(d);
// 将arr数组中最后一项 “g”去掉 并将d数组中 ["d", "e", "f", 
arr.splice(arr.length - 1, 1, ...d);
console.log(arr); // ["a","b","c","d","e","f","d","e","f","g"]
```


## 16.10 ES6中新方法
**方法的分类**

- 静态方法
    指的是类本身调用的方法叫做静态方法 在类本身 由类调用
- 普通方法
    指的是类的原型上的方法 在原型上 由实例调用
```JavaScript
// 定义类
function Dog() {
}

// 定义普通方法
Dog.prototype.xxx = function() {}

// 定义静态方法
Dog.sayHello = function() {}
```
## 16.11 字符串方法
- startsWith(str, pos) 方法判定字符串是否是以指定的字符串开头(其实是从某个位置开头 默认是从头开始判定)
    - str 被判定的字符串
    - pos 截取的位置(可选,默认为0)
    - 返回值 布尔值 true表示包含 false表示不包含
```JavaScript
// startsWith
// 该方法判定字符串是否是以指定的字符串开头(其实是从某个位置开头 默认是从头开始判定)
let str = "今天天气不错";
// 判定str是否是以"今天"开头
let result = str.startsWith("今天");
console.log(result);
// 判定 "天气"是不是从str的下标2开始
let result1 = str.startsWith("天", 1);
console.log(result1);
```
- endsWith(str, pos) 该方法判定字符串是否是以指定的字符串结尾(其实是从某个位置结尾 默认是从末尾开始判定)
    - str 被包含的字符串
    - pos 截取的末尾位置(数值依旧是字符串的下标 从头开始截取到该位置 不包含该位置)
    - 返回值 布尔值 true表示包含 false表示不包含
```JavaScript
    let str = "今天天气不错";
    // 判定是否是以"错"结尾
    let result = str.endsWith("错");
    console.log(result);

    // 判定字符串的到倒数第二个字是否是以"不"结尾  
    let result1 = str.endsWith("不", 5);
    console.log(result1);
```
- includes(str, pos) 该方法判定字符串中是否包含另一个字符串
    - str 被包含的字符串
    - pos 判定的起始位置
    - 返回值 布尔值 true表示包含 false表示不包含
```JavaScript
    let str = "今天天气不错";
    // 判定str中是否包含 "气" 这个字
    let result = str.includes("气");
    console.log(result);

    // 判定str中从下标3开始往后 是否包含"气"这个字
    let result1 = str.includes("气", 3);
    console.log(result1);
```

- repeat(num) 方法 用于重复字符串 
    - num 数字 表示重复次数
    - 返回值 重复之后的字符串
```JavaScript
    let str = "今天天气不错";
    let str1 = str.repeat(20);
    console.log(str1);
```

## 16.12 数组方法
- Array.of(a, b, c, d, ...) 定义数组
    - 每一个参数都是数组的成员
    - 返回值 数组
```JavaScript
    var arr1 = Array.of(10); // Array.of消除了new Array时 只有一个参数 会因为类型的不同而产生的歧义
```
- Array.from(likeArray) 用于将类数组对象转为真正的数组
    - likeArray 类数组对象
```JavaScript
    // 获取类数组对象
    var lis = document.getElementsByTagName("li");
    console.log(lis);
    // 以前我们可以这么转换
    var arr = [].slice.call(lis);
    console.log(arr);
    // 现在可以通过Array.from
    var arr1 = Array.from(lis);
    console.log(arr1);
```

- find(handler) 用于以条件查询数组中的成员
    - handler 函数 有三个参数 
        - 成员 
        - 成员下标 
        - 数组本身 
        - 返回值 返回布尔值 如果为真 则停止循环并返回对应的成员
    - 返回值 当参数函数返回真时 返回对应成员 如果没有任何一个返回真 则返回 **undefined**
```JavaScript
    var arr = ["浦东", "奉贤", "宝山", "青浦", "闵行", "徐汇"];
    var baoshan = arr.find(function(value, index, arr) {
        // console.log(value, index, arr);
        return value.includes("山");
    });
    console.log(baoshan); 
```
- findIndex(handler) 用于以条件查询数组中的成员对应的下标
    - handler(value, index, arr) 函数 有三个参数 
        - value 成员 
        - index 成员下标 
        - arr 数组本身 
        - 返回值 返回布尔值 如果为真 则停止循环并返回对应的成员
    - 返回值 当参数函数返回真时 返回对应成员下标 如果没有任何一个返回真 则返回 **-1**
- copyWithin(pos, start, end) 用于数组的内部复制 从start开始复制到end结束(不包含) 再将复制的内容从pos开始一一往后替换
    - pos    替换的位置下标 
    - start  复制的开始位置下标(**包含**)
    - end    复制的结束位置下标(**不包含**)
    - 返回值  原数组 注：**该方法会改变原数组**
```JavaScript
    var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];
    arr.copyWithin(1, 4, 7);
    console.log(arr); // [1, 5, 6, 7, 5, 6, 7, 8, 9]
```

 -  fill(any, start, end)  填充方法
     -  any  填充值 
     -  start 起始位置(包含) 
     -  end  结束位置(不包含)
     -  特点：会改变原数组

```JS
var arr = [1, 2, 3, 4, 5, 6];
arr.fill("ok"); // ["ok", "ok", "ok", "ok", "ok", "ok"]

var arr1 = [1, 2, 3, 4, 5, 6];
arr1.fill("ok", 2); // [1, 2, "ok", "ok", "ok", "ok"]

var arr2 = [1, 2, 3, 4, 5, 6];
arr2.fill("ok", 2, 5); // [1, 2, "ok", "ok", "ok", 6] 
```

输出：

![1609837208599]()

## 16.13 对象方法

- Object.is(one, two) 用于比较两者是否全等
    - one 比较的一方
    - two 比较的另一方
```JavaScript
    // 这里主要说明它与 === 的不同
    console.log(NaN === NaN);  // false 
    console.log(Object.is(NaN, NaN)); // true

    console.log(0 === -0); // true
    console.log(Object.is(0, -0)); // false
```
> 能使用 == 和 === 时就尽量不要使用 Object.is(..)，因为前者效率更高、 更为通用。Object.is(..) 主要用来处理那些特殊的相等比较。



- Object.assign(target, source, source1, ...) 方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）
    - 方法的第一个参数是目标对象，后面的参数都是源对象。
    - 有同名属性，则后面的覆盖前面的。
    - 如果只有一个参数，`Object.assign()`会直接返回该参数。
    - 如果该参数不是对象，则会先转成对象，然后返回。
    - `undefined`和`null`作为参数会报错
```JavaScript
    var obj = {

    }
    var obj1 = {
        color: "Red",
        age: 33,
        girlFriend: {
            name: "小花"
        }
    }

    var obj2 = {
        account: "sdifhsidhf"
    }

    // 将obj1和obj2的所有属性和方法复制一份给obj
    Object.assign(obj, obj1, obj2);
    // 复制之后再输出 就已经具备了很多属性和方法
    console.log(obj);

    console.log(obj1.girlFriend === obj.girlFriend) // 地址相同   
    // 修改obj的属性内容
    obj.girlFriend.age = 13;
    console.log(obj1.girlFriend) // 影响到obj1的属性了
```



# 十七、面向对象

## 17.1 简介

“面向过程”(Procedure Oriented)是一种以过程为中心的编程思想。 

​    我们之前写的所有代码都是面向过程的  

“面向对象”(Object Oriented)是软件开发方法，一种编程范式。把相关的数据和方法组织为一个整体来看待，从更高的层次来进行系统建模，更贴近事物的自然运行模式。

​	我们不再重复书写过程，而是将过程封装成函数，每一次调用这个函数时，就会得到一个对象，该对象所具备功能与之前面向过程的功能是一模一样的。 

## 17.2 面向过程
- 如果是面向过程 去描述一个人 每一条属性都要自己定义 书写的是定义的过程 叫做面向过程

```JavaScript
// 如果是面向过程 去描述一个人 每一条属性都要自己定义 书写的是定义的过程 叫做面向过程
var obj = {
    name: "zhangsan",
    age: 13,
    sex: '男'
}
// 如果要再定义一个人 需要再写一遍
var obj1 = {
    name: "lisi",
    age: 14,
    sex: "男"
}
// 如果要再定义一个人 需要再写一遍
// ……
// 这么写代码 可以 但是比较繁琐
```

## 17.3 面向对象
### 17.3.1 工厂函数
-  如果能够有一种方式 能够快速的生成一个对象 我们就不用每次都从头到尾敲一遍
```JavaScript
function createPerson() {
    return  {
        name: "lisi",
        age: 14,
        sex: "男"
    }
}
// 自从有了createPerson函数之后，就每调用一次 就可以得到一个对象
var obj = createPerson();
var obj1 = createPerson();
console.log(obj)
console.log(obj1) 
```
> 提示： 这种可以返回内容的函数，我们称之为“工厂”。这种书写代码的模式，叫做工厂模式。属于设计模式的一种。
> 问题： 虽然可以创建 但是内容完全一致 我们希望内容可变

思考：函数中的什么内容可以发生变化？
答案：参数是可以变化的
于是 我们将可变的部分提取成参数 由外部传入

```JavaScript
function createPerson(name, age, sex) {
    return  {
        name: name,
        age: age,
        sex: sex
    }
}
var obj = createPerson("张三", 13, "男");
var obj1 = createPerson("李四", 14, "男");
console.log(obj);
console.log(obj1);
```
定义"人"的工厂创建完毕 现在再定义一个"车"的工厂

```JavaScript
function createCar(type, color, price) {
    return {
        type: type,
        color: color,
        price: price
    }
}
function createPerson(name, age, sex) {
    return  {
        name: name,
        age: age,
        sex: sex
    }
}
// 调用函数创建一个人
var p = createPerson("张三", 13, "男");
// 调用函数创建一辆车
var c = createCar("五菱宏光", "blue", 108000);
console.log(p);
console.log(c);
// 想要分辨两个对象各自的类型 
console.log(Object.prototype.toString.call(p)); // [object Object] 
console.log(Object.prototype.toString.call(c)); // [object Object]
```
> 结论：想要分辨两个对象各自的类型 无法分辨 
> 注: Object.prototype.toString.call()这种方式虽然可以检测到JS内置的构造函数名称,但是无法分辨自定义的构造函数名称



## 17.4 构造函数
用于构造对象的函数，叫做构造函数。 
1. 用new调用
2. 首字母要大写
3. 内部要通过this给实例添加属性
4. 内部最好不要出现return
   1. 如果出现了return 返回的如果是值类型 则忽略return
   2. 如果出现了return 返回的如果是引用类型 则以return为准
5. 对象的类型是构造函数名称

### 引导
```JavaScript
function createPerson() {
}
function createCar() {
}
// 构造函数： 此时 createPerson和createCar的作用就是在构造对象 这样的函数叫做构造函数
// 构造函数就是普通函数 
// 如果使用new调用 就是构造函数 会返回对象
var p = new createPerson();
var p1 = new createPerson();
var c = new createCar();
// 如果不使用new调用 就是普通函数 是否返回内容要取决于是否有return
var d = createPerson();
var e = createCar();
```
> new 是一个关键字 它的作用类似于运算符 是一种调用函数的方式 
> new 的英文意思： 新的 也就是说 一旦new了 就希望得到一个新对象
> 注：构造函数其实就是普通函数 如果使用new调用 就是构造函数 会返回对象 如果不使用new 就是当做普通函数在调用 是否有返回内容要取决于是否有return


### 构造函数执行时
构造函数在执行的时候：
- 开辟一个内存空间(空对象)
- 将空对象与this绑定
- 然后让这个空对象的 \_\_proto__ 指向函数的原型prototype，继承了该函数的原型。
- 执行函数体中的代码
- 返回这个this地址


## 17.5 安全类
属于设计模式的一种 能够保证不论程序员使用new还是不使用new都可以得到实例对象。

```JavaScript
function Person() {
    if (this === window) {
        // 说明外面没有new 就是当普通函数来调用的 外部想要得到返回内容 内部就得有return
        return new Person();
    }
}
var p = new Person();
var p1 = Person();
// p 和 p1都是Person的实例
```

## 17.6 称呼问题
用于构造对象的函数叫做构造函数。
构造函数构造出来的对象叫做实例。

对象称呼构造函数的原型叫作原型对象(\_\_proto\_\_)。



## 17.7 原型的推导过程
要搞明白原型是什么，先来看问题：

```JavaScript
// 定义构造函数
var Animal = function(eye, weight) {
    this.eye = eye;
    this.weight = weight;
    this.eat = function() {
        console.log("吃东西");
    }
    this.sleep = function() {
        console.log("zzzzzzzzzzzzzzz...")
    }
}

var a1 = new Animal("眼睛", 100);
a1.eat();
a1.sleep();

var a2 = new Animal("眼睛1", 200);
a2.eat();
a2.sleep();

console.log(a1.eat === a2.eat); // false 
```
> 问题: 既然是同样的方法 最好在内存中只保留一个 能够被每一个实例复用
> 思考: 之所以每一个实例的方法的地址不同 是因为每一次执行构造函数的时候 都定义了两个新函数 

```JavaScript
// 定义构造函数
var Animal = function(eye, weight) {
    this.eye = eye;
    this.weight = weight;
    this.eat = eat;
    this.sleep = sleep;
}
// 之所以每一次都定义两个新函数 是因为定义函数的代码放在了构造函数里
// 现在将代码抽取到函数的外部  这样就只会定义一次 不论初始化多少Animal的实例 都共用同一个方法
var eat = function() {
    console.log("吃东西");
}
var sleep = function() {
    console.log("zzzzzzzzzzzzzzz...")
}

var a1 = new Animal("眼睛", 100);
a1.eat();
a1.sleep();

var a2 = new Animal("眼睛1", 200);
a2.eat();
a2.sleep();

console.log(a1.eat === a2.eat); // true
```
> 结论：虽然将代码抽取到外部 可以解决复用的问题 但是污染了外部的作用域 也就意味着:定义一个构造函数 还要定义一堆变量 定义一堆函数 这也不合适

> 为了解决外部环境的污染问题 我们就定义**一个**变量 保存**一个**对象 将所有的函数都挂载在该对象身上

```JavaScript
var Animal = function (eye, weight) {
    this.eye = eye;
    this.weight = weight;
    this.eat = prototype.eat;
    this.sleep = prototype.sleep;
}
// 为了解决外部环境的污染问题 我们就定义一个变量 保存一个对象 将所有的函数都挂载在该对象身上
var prototype = {
    eat: function () {
        console.log("吃东西");
    },
    sleep: function () {
        console.log("zzzzzzzzzzzzzzz...")
    }
}

var a1 = new Animal("眼睛", 100);
a1.eat();
a1.sleep();

var a2 = new Animal("眼睛1", 200);
a2.eat();
a2.sleep();

console.log(a1.eat === a2.eat); // true

```
> 现在只剩下一个变量 可是这一个对象我们也不想要 所以可以挂载到函数本身 => **Constructor.prototype**  我们能够考虑到这个问题 JS之父布兰登·艾奇也想到了 于是，他规定每一个函数都有一个属性**prototype** 而该对象 它身上的内容都可以被构造函数的实例访问到 **用于共享方法和属性** 默认有一个属性 **constructor**指向构造函数本身

## 17.8 原型查找机制

![1610348938255](images/1610348938255.png)

原型查找机制： 当一个对象调用属性时,会先查找自身是否具备,如果有,就用 如果没有 会查找自身的构造函数的原型(原型对象)是否具备 如果有就用 如果没有 就继续向上查找(因为原型对象也是对象 查它的属性又触发了它的原型查找机制) 直到Object.prototype为止 因为再往上就是null

## 17.9 对象类型的分辨
- 方式 Object.prototype.toString.call(对象)
- 学习了原型之后，我们就可以使用 **实例.constructor** 来获取对象的构造函数 进而判定对象的类型
- instanceof （见17.10）


## 17.10 instanceof
用来检测一个**对象**是否是**函数**的实例
返回值是布尔值

```
var arr = new Array();
console.log(arr instanceof Array); // true
```

但是需要注意的是，如果后面的函数在前面对象的原型链上，也会判定为真

```
console.log(arr instanceof Object); // true
```



## 17.11 hasOwnProperty 
该方法是ES5中新增的方法 用于检测一个对象的属性是否是该对象自身的属性
如果是自身属性 返回true 否则返回false

```
function People (name, age, sex) {
	this.name = name;
	this.age = age;
	this.sex = sex;
}
People.prototype.sayHello = function() {
	console.log("hello")
}
var p = new People("小明", 12, "男");
p.hasOwnProperty("name"); // true  name是p自身的属性
p.hasOwnProperty("sayHello"); // false  sayHello不是p自身的属性

```



# 十八、服务器相关

## 思考
    我们现在已经学习完HTML CSS以及一部分JS 所以当写完一个HTML页面之后 如何让别人看到?
## 小故事
```
爱因斯坦, 发表了一篇文章, <<相对论>>. 世界上的人都想看. 在没有计算机的时代,通过报纸 邮件进行传递.
后来有了计算机.人们可以通过计算机进行数据传递了. 如果谁要就发给谁,那么会很累.所以爱因斯坦想:"我不发了,你们来取". 所以爱因斯坦就找了一台计算机，让它24小时开机，把文章放在这台电脑上，运行了一个程序。谁通过电脑访问这个服务器谁就能够看到文章内容. 这个计算机，我们就管它叫做硬件服务器。同样的运行起来的这个程序，叫作软件服务器。
所以服务器就是一台计算机运行了一个程序.这个程序就是服务器,它可以对请求做出响应.

下一个问题:有了服务器,可以进行数据的响应.那么就必然要有一个查看方式.
    这个查看方式就是通过电脑，更准确的说，应该是电脑上的浏览器应用程序(IE、Chrome、FireFox等).

下一个问题:服务器和浏览器之间进行数据传递,如何保证看到的就是服务器上的原本的内容呢?
    于是服务器和浏览器之间就进行了协定: 
        浏览器说:我按照这个格式发送请求
        服务器说:那我就按照这个格式解析请求
        服务器说:我按照这个格式进行响应内容
        浏览器说:那我就按照这个格式解析响应内容
    于是协议达成,这个协议叫做HTTP协议.
    
后来,牛顿也搭建了一个服务器.此时服务器就有多台.问题来了，如何区分不同的服务器?
    答案: IP地址 IP是计算机的 唯一身份证。 每台电脑都有一个IP地址。(就好比人类的身份证号)每一台服务器，都应当有一个公网的IP地址。（占据公网的一块区域，为了方便记忆，我们就有了域名）
    比如: www.aixinsitan.com  转换成IP地址可能是: 10.30.151.23
    比如: www.niudun.com      转换成IP地址可能是：11.5.232.171
    
    但是人类如果去记IP地址,不方便,所以就将IP地址映射成了"域名"
    域名与IP地址的映射列表所在的地址: DNS服务器  Domain Name Server
    "根域名"服务器在全球一共13台 
```

## 服务器
    就是计算机,但是与普通计算机有区别: 保密性/安全性/稳定性的不同
    服务器分硬件和软件,它们一起组成服务器.
## 浏览器
    负责发送请求,请求服务器上的内容并显示出来.
## HTTP协议  
    全称  HyperText Transfer Protocal
    作用: 规定前后端之间的数据传输
## 域名
    用于区分不同的服务器的字符串 
## DNS服务器
    域名与IP地址的查找服务器

 





































